{"categories":[{"title":"ACM","uri":"https://coder-liuu.github.io/categories/acm/"},{"title":"Linux","uri":"https://coder-liuu.github.io/categories/linux/"},{"title":"机器学习","uri":"https://coder-liuu.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"title":"相册","uri":"https://coder-liuu.github.io/categories/%E7%9B%B8%E5%86%8C/"},{"title":"面试题","uri":"https://coder-liuu.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"默认分类","uri":"https://coder-liuu.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"}],"posts":[{"content":" 游戏==伪现实，无脑，哈哈哈\n 失落城堡-联机时的快乐  铁绣战争-无联机不快乐  元气骑士-大一寒假玩的，不错  荒野乱斗-恩哼，容易上瘾，我5000个杯了  饥荒-百玩不腻  缺氧-恐怕我先缺氧了   今天就先想到了折磨多，以后想到在填。\n ","id":0,"section":"posts","summary":"游戏==伪现实，无脑，哈哈哈 失落城堡-联机时的快乐 铁绣战争-无联机不快乐 元气骑士-大一寒假玩的，不错 荒野乱斗-恩哼，容易上瘾，我5000个杯","tags":null,"title":"游戏，哈哈哈","uri":"https://coder-liuu.github.io/2021/09/album-game/","year":"2021"},{"content":" 无聊的八股文，呜呜呜！\n 操作系统   操作系统的组成，功能？\n文件管理模块：文件的存储位置的管理、文件权限的管理等。\n进程控制模块：进程通信、管理控制、死锁处理等。\n设备管理模块：设备分配、虚拟设备等。\n内存管理模块：管理内存、内存分配、内存保护和共享等。\n处理器管理模块：管理CPU。\n  进程、线程的概念以及区别？\n进程：一次程序执行的过程。 线程：轻量级的进程，一个进程中可以有多个线程。 区别：\n(1) 进程是资源分配的最小单元，线程是资源调度的最小单元\n(2) 进程拥有系统资源，所有线程共享进程的资源\n(3) 创建一个进程需要资源的分配和回收，而创建线程不需要\n  进程间的通信方式？\n(1) 管程，一个进程向其写程序，一个进程从中读取程序，是一个先进先出的结构，在linux可以用mkfifo创建管道，管道的生命周期为进程的开始与结束。\n(2) 消息队列，消息队列是信息的链表，具有写权限的程序可以发送消息，具有读权限的程序可以接受程序。如果不释放消息队列或关机，消息队列会一直存在。\n(3) 共享内存，两个进程的一块内存都映射到同一块物理内存，多个进程就可以访问同一内存空间了。\n(4) 信号量，为了防止多个进程操作同一内存空间，使用计数器来控制进程的访问。控制信号量通常有两种操作，P信号量减一，V信号量加一。\n(5) 信号，进程之间的异常通信，比如在Linux中使用kill命令终止程序\n(6) socket，不同主机进程之间的通信\n  线程间的通信方式？\n(1) 共享全局变量\n(2) 使用监听器\n(3) 使用消息完成通信，一个发消息，一个收消息\n  进程有哪几种状态，之间的转换？\n(1) 就绪态，执行态，阻塞态\n(2) 之间的转换\n5.1 就绪-执行，CPU来了\n5.2 执行-就绪，时间片完毕，等待下一次\n5.3 执行-阻塞，需要IO输入\n5.4 阻塞-就绪，IO输入有了\n  进程调度策略\n短作业优先、先来先服务、时间片轮转、高相应比优先\n  什么是死锁，产生死锁的四个必要条件，如何预防死锁？ 死锁：多个进程因资源竞争而陷入一种互相等待的过程。\n四个必要条件：互斥条件（不放弃），占用且等待，不可抢占，循环等待\n预防死锁：银行家算法，当一个进程申请使用资源时，系统试探性的分给他资源，然后判断系统是否安全，如果安全分配，不安全不分配。\n  页面置换算法\n先进先出置换算法（FIFO）:队列结构，每次替换都是入队出队的操作\n最近最久未使用算法(LRU)：FIFO算法优化，如果当前页面存在队列中，把这个页面移动到队尾。\n最不常用置换算法（LFU）统计每个页面使用的次数，替换出现次数最少的页面\n最佳页面置换算法（OPT）每次替换到未来最远需要的页面（理论最佳算法，实际不能用）\n  计算机组成原理   冯诺依曼机的体系结构\n计算器、存储器、控制器、输入设备、输出设备\n  cpu一个指令周期的流程是什么\n取指令：将一条指令从主存中放入指令寄存器当中。\n指令译码阶段：对指令进行拆分和解释\n执行指令：完成指令的操纵\n访存取数：访问主存读取操作\n结果写回阶段：将运算结果写回到某种存储形式\n  ","id":1,"section":"posts","summary":"无聊的八股文，呜呜呜！ 操作系统 操作系统的组成，功能？ 文件管理模块：文件的存储位置的管理、文件权限的管理等。 进程控制模块：进程通信、管理控制、","tags":null,"title":"操作系统AND计组面试题","uri":"https://coder-liuu.github.io/2021/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fand%E8%AE%A1%E7%BB%84%E9%9D%A2%E8%AF%95%E9%A2%98/","year":"2021"},{"content":" 菜鸟写的，大佬轻喷。。\n 计算机网络   OSI和TCP/IP模型各个层的名称\n(参考资料：https://www.cnblogs.com/qishui/p/5428938.html)\nOSI七层结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。\nTCP/IP结构 ：物理层、数据链路层、网络层、传输层、\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;、应用层\n  TCP/IP模型每层的功能\n2.1 物理层：传输比特流。\n2.2 数据链路层：封装成帧、点对点传递、差错控制\n2.3 网络层：分组交换、路由选择\n2.4 运输层：负责两个主机进程之间的通信。\n2.5 应用层：直接为用户的应用进程提供服务。\n  TCP/IP模型每层的协议\n3.1 物理层：忽略\n3.2 数据链路层：CMSA/CD(载波监听多点接入碰撞检测协议),PPP(点对点协议，传输数据报的一种方法)\n3.3 网络层：ARP(地址解析协议),RARP 3.4 运输层：TCP(传输控制协议)、UDP(用户数据报协议，可靠性低)\n3.5 应用层：HTTP(超文本传输协议，客户端/服务器访问协议)、SSH、FTP(文件传输协议)、DHCP(动态分配IP地址)\n  计算机网络为什么要分层？优点？\n4.1 各层之间互相独立，上层不需要知道下层的结构，只使用下层提供的服务。\n4.2 灵活性，促进标准化。\n  简述一下层次路由的原理\n每个路由器只知道将数据包发送到自己所在区域内的目标地址，对于其他区域的内部结构不知道。节省了路由表的空间。\n  协议三要素\n语义：控制信息每部分的意义\n语法：用户数据与控制信息的格式，数据出现的顺序\n时序：对事件发生顺序的详细说明\n  香农公式意义是什么\n香农公式给出了在信道上进行无差错传输的最大速率。\n  简述一下CSMA/CD协议\n在一个半双工信道上，先听再发，边听边发，冲突停止，随机重发\n先听再发：在发送数据前，检测信道是否空闲，空闲了在发送。\n边听边发：发送数据时，检测信道。\n冲突停止，随机重发：因为冲突而重发丢失的数据。\n  TCP和UDP的异同点\n相同点：都是传输层的协议，进行传输数据\n不同点：\nTCP：是一个有连接的可靠协议，可靠性高，速度慢。\nUDP：是一个无连接的不可靠协议，不可靠，但是速度快。\n  TCP的三次握手四次挥手过程？\n(1)三次握手\n主机A$\\longrightarrow$(SYN)主机B\n主机A$\\longleftarrow$(ACK)主机B\n主机A$\\longrightarrow$(ACK)主机B\n(2)四次挥手\n主机A$\\longrightarrow$(FIN)主机B\n主机A$\\longleftarrow$(ACK)主机B\n主机A$\\longleftarrow$(FIN)主机B\n主机A$\\longrightarrow$(ACK)主机B\n  为什么会采用三次握手，若采用二次握手可以吗?\n如果采用二次握手，如果第一次主机B给主机A回ACK包时发生了延迟，导致主机A重新给主机B发送SYN包，最终可能会主机A和主机B建立了两个TCP连接。\n  简述下TCP建立连接的过程,TCP如何保证可靠传输？\n检验和：保证数据一样\n序列号：应答作用，保证数据有序，不重复\n超时重传：保证对方收到数据包\n连接管理：三次握手、四次挥手\n流量控制：尽可能多发\n拥塞控制：控制滑动窗口大小，保证网络不堵塞\n  在TCP拥塞控制中，什么是慢开始、拥塞避免、快重传和快恢复算法？\n慢开始：拥塞窗口大小每次×2\n拥塞避免：当拥塞窗口增大到一定阈值之后，拥塞滑动窗口大小每次+1\n快重传：收到1个报文的3个ACK之后立即重传，不需要等到超时\n快恢复：阈值设置为当前当前拥塞窗口的一半，拥塞窗口大小等于阈值，然后进行拥塞避免算法\n  流量控制和拥塞控制是什么关系?\n流量控制：让对方来得及接收数据。\n拥塞控制：避免给整体网络带来堵塞。\n流量控制是一个点对点的问题，拥塞控制是一个全局性的过程。\n  简述下DNS域名解析的过程。 (1) 在本地缓存中查找，在linux中就是/etc/hosts文件\n(2) 在本地DNS服务器查找\n(3) 在根域名DNS服务器查找，返回对应根域名的服务器\n(4) 在顶级域名DNS服务器查找，返回对应顶级域名的服务器\n(5) 在权威域名DNS服务器查找，返回对应IP地址\n  点击网页一次HTTP请求过程？\n(1) URL规范化，也就是去除参数\n(2) 通过DNS将域名解析为ip地址\n(3) 根据ip，建立TCP连接，三次握手\n(4) 发起HTTP请求，获得html页面\n(5) 客户端解析页面并渲染\n(6) 服务器断开连接，四次挥手\n  MAC地址和ip地址区别？\nmac地址用来局域网电脑的通信，有了ip地址可以完成互联网中电脑之间的通信\n  HTTP状态码及其含义, HTTP和HTTPS的区别\n1xx：信息提示性\n2xx：请求成功\n3xx：资源重定向\n4xx：客户端错误\n5xx：服务器错误\n  HTTPS比HTTP多了一个SSL加密的过程，更安全。\n DHCP的作用：\n一个应用层的协议，动态为主机分配IP地址。\n  什么是socket？\nsocket是基于TCP/IP协议的应用程序之间的通信方式，通信前程序需要知道另一个程序的IP地址和端口。\n  简述一下Cookie和Session的区别\n(1) Cookie的数据信息存在客户端，Session的数据信息存在服务器当中。\n(2) Cookie存储在本地，Session比较安全。\n(3) Cookie存储类型有限，而Session可以存储任意类型的数据类型。\n  ","id":2,"section":"posts","summary":"菜鸟写的，大佬轻喷。。 计算机网络 OSI和TCP/IP模型各个层的名称 (参考资料：https://www.cnblogs.com/qishui","tags":null,"title":"计算机网络面试题","uri":"https://coder-liuu.github.io/2021/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/","year":"2021"},{"content":" 呜呜呜，又是看八股文的一天。\n 数据结构   O(n)的大O是什么意思？什么是时间复杂度?\n答：大O是最坏情况下的时间复杂度。时间复杂度是评价算法运行速度的快慢，是最基本语句的执行次数。\n  线性存储结构和链式存储结构的优点?\n线性存储支持随机存取数据，速度快。\n链式存储插入和删除数据不需要移动大量元素，底层存储时可以不连续。\n  解释一下顺序存储与链式存储\n顺序存储：所有元素存放在一块连续的存储区域中，这块区域通常可以用一个数组来表示。\n链式存储：链式存储不要求相邻元素的实际物理位置相邻，只需要存储相邻元素的位置即可。\n  头结点和头指针的区别？\n头结点：链表中的第一个结点\n头指针：头节点的地址\n  栈和队列的区别\n区别：栈是一个后进先出的结构，队列是一个先进先出的结构。\n  有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？\n(F的位置-P的位置+n)%n. （PS:P的位置可能大于F的位置，所以需要加N）\n  如何区分循环队列是队空还是队满？\n最简单的方法就是在循环队列中加入一个元素个数的标记方法。\n也可以牺牲一个位置，不用来存储，这样头指针+1==尾指针，队列满；头指针==尾指针，为队列空。\n  大顶堆实现及应用\n大顶堆实际上是一棵完全二叉树，任何节点都比其左右孩子大。堆的应用有堆排序，解决TopK的问题。\n  哈希表的概念？哈希冲突的解决办法？ 哈系表，又称为散列表。是一个根据键来找到对应值的数据结构。通过哈希函数将键映射到内存位置。\n冲突通常有两种解决办法：\n(1) 拉链法，在映射到的位置来一个链表来进行存储\n(2) 开放地址法，从映射位置往后找一个空位置来进行存储\n  判断链表是否有环（非常重要！）\n标记法、快慢双指针法。\n对于快慢双指针法找到入环点可以，一个指针指向起点，一个指针指向重合点，相遇点就是入环点。\n  平衡二叉树、二叉排序树、完全二叉树的定义\n平衡二叉树：它的左右两个子树高度差的绝对值不超过1，并且左右两个子树都是二叉平衡树。\n二叉排序树：又称二叉查找树，根结点的值大于全部左子树的值，根结点的值小于全部右子树的值。左右子树仍是二叉查找树。\n二叉搜索树：叶结点只在最后一层或者次后层，最后一层的叶结点只能在最左边。\n  如何由遍历序列构造一颗二叉树？已知先序序列和后序序列能否重现二叉树？ 先序(根)遍历：遍历顺序，根-左-右.\n中序(根)遍历：遍历顺序，左-根-右.\n后序(根)遍历：遍历顺序，左-右-根.\n不能，无法确定根结点了\n  B树是什么?在数据库中有什么应用？\nB树是一个优化的二叉搜索树，一个结点可以有多个值，减小了树的高度。数据库通常使用B树进行索引。\n  红黑树是什么？\n由于平衡二叉树每次插入和删除都需要作出复杂的操作，所以红黑树的特点在查找效率和插入删除数据花费时间作出了权衡。\n  二分搜索和单纯的线性搜索的区别?\n二分查找时间复杂度是O(logN)，线性搜索时间复杂度是O(N)。\n二分查找要求数据是有序的，线性搜索对数据没有要求。\n  各种排序的思路\n冒泡排序：两两比较每次把最值元素拿出来。\n插入排序：每次将一个待排序的数，插入到排好序的数组中去。\n选择排序：跟冒泡排序差不多，遍历未排序部分，然后拿出来。\n快速排序：将数组分为两部分，一部分比基数大，一部分比基数小，然后在递归。O(Nlog(N))\n堆排序：构建一个堆每次取堆顶元素。O(Nlog(N))\n归并排序：分成子问题，合并两个有序数组。O(Nlog(N))\n  最短路算法思路\n每次选择最近的一个点，然后使用这个点优化距离表。\n  最小生成树算法思路\n(1) Kruska算法，时间复杂度(ElogE,E边数)\n1.1 对所有边进行排序\n1.2 挑一个权重最小的边\n1.3.1 如果不联通，加入这条边。如果联通，不加入这条边。\n  (2) Prim算法，时间复杂度(NN,N顶点数)\n2.1 随机选取一个点\n2.2 选择离他最近的点，然后加上边\n2.3 重复步骤1-2\n 邻接表和邻接矩阵\n邻接表，存储的是该点的所有邻居结点.\n邻接矩阵，如果相邻是1,不相邻是0.\n  介绍一下深度优先搜索和广度优先搜索是如何实现的？\nDFS： 递归实现\nBFS： 使用队列存储待遍历结点\n  介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。 朴素的匹配算法： 一个一个匹配，暴力法。\nKMP算法：在匹配失败的情况下，利用之前比较的情况，来使主串的起始点更靠后。(我是半瓶水)\n  ","id":3,"section":"posts","summary":"呜呜呜，又是看八股文的一天。 数据结构 O(n)的大O是什么意思？什么是时间复杂度? 答：大O是最坏情况下的时间复杂度。时间复杂度是评价算法运行速","tags":null,"title":"数据结构面试题","uri":"https://coder-liuu.github.io/2021/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE%E9%9D%A2%E8%AF%95%E9%A2%98/","year":"2021"},{"content":" 2021-8-17更新: 本文仅作尝试，记录一些用法，不做深入探究。\n 自己以前经常用Python，这次通过Go还是学习到了很多知识，比如反射，socket网络编程等。\nGo玩完了，接下来打算认真学习一下Java，比较还是要吃饭的嘛！\n估计我100年后可能需要Go，也许会回过头来，在看看这篇博客。\n基础知识 1. 变量和常量定义 var a1 int var a2 int = 3 a3 := 3 // 更简洁的方法 // 常量A,B,C const ( A = iota + 1 B C )  .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Warning\n如果定义变量不使用会编译器会拒绝编译\n 2. 导入和输出 import \u0026quot;fmt\u0026quot; import ( _ \u0026quot;fmt\u0026quot; // 匿名导入，可以不使用 ) fmt.Println(\u0026quot;Hello World\u0026quot;)  3. 数组和字典 var a1 [3]int // 数组 a2 := [3]int {1,2,3} a3 := []int {2,3,4} // 动态数组 // 遍历数组 for index, value := range(a3) { fmt.Println(\u0026quot;index = \u0026quot;,index,\u0026quot; ;value = \u0026quot;,value) } // 切片 slice1 := make([]int,3,5) // 大小为3,容量为5的数组 // 字典知识 var m1 map[string]int // 声明字典 m1 = make(map[string]int) // 分配空间 m1[\u0026quot;one\u0026quot;] = 1 // 其他创建方式 m2 := make(map[string]int) m3 := map[string] string { \u0026quot;one\u0026quot; : \u0026quot;1\u0026quot;, \u0026quot;two\u0026quot; : \u0026quot;2\u0026quot;, }  4. 函数 fun add(x int) int{ return x + 1 } fun add_point(x *int) { *x = *x + 1 }  5. 结构体 // 声明结构体 type Human struct { name string sex string } // 绑定方法 // 方法名称: 大写为共有，小写为私有 // 绑定时: 有星为引用，无星为值传递 func (this *Human) Show() { fmt.Println(\u0026quot;name = \u0026quot;,this.name) fmt.Println(\u0026quot;sex = \u0026quot;,this.sex) } // 对象继承 type SuperMan struct { Human level int } h := Human{\u0026quot;zhangsan\u0026quot;,\u0026quot;male\u0026quot;} h.Show() s := SuperMan{Human{\u0026quot;li3\u0026quot;,\u0026quot;male\u0026quot;},88} s.Show()  6. 接口 /* 步骤: 1. 有一个父类接口 2. 实现了所有方法 3. 指向子类 */ // 动物类接口 type Animal interface { Sleep() GetColor() string GetType() string } // Cat 对象 type Cat struct { color string } func (this *Cat) Sleep() { fmt.Println(\u0026quot;Cat is sleep\u0026quot;) } func (this *Cat) GetColor() string{ return this.color } func (this *Cat) GetType() string{ return \u0026quot;Cat\u0026quot; }  7. 反射简单类型 import \u0026quot;reflect\u0026quot; var num2 int32 = 12 reflect.TypeOf(num2) reflect.ValueOfnum2)  8. 并发 // go 关键字+匿名函数 !当主程序结束会自动结束 go func() { ... }() // goroute之间进行通信 c := make(chan int) // 不带缓冲的 c := make(chan int, 3) // 缓冲为3 c \u0026lt;- 666 // 向信道发送(有阻塞特性) num := \u0026lt;-c // 从信道接受 close(c) // 关闭信道 // 多信道选择,收到任意一个就执行 select { case c \u0026lt;- x1: fmt.Println(\u0026quot;x1\u0026quot;) case c \u0026lt;- x2: fmt.Println(\u0026quot;x2\u0026quot;) }  相关学习视频 Thecw第一集\nThecw第二集\n8小时讲解\n","id":4,"section":"posts","summary":"2021-8-17更新: 本文仅作尝试，记录一些用法，不做深入探究。 自己以前经常用Python，这次通过Go还是学习到了很多知识，比如反射，s","tags":null,"title":"Go语言学习笔记","uri":"https://coder-liuu.github.io/2021/08/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","year":"2021"},{"content":" Apriori算法是经典的数据关联规则的算法，接下来让我们一起回顾Apriori算法吧！\n 1. 算法背景 在沃尔玛超市中，商店人员发现购买尿布的人往往也会购买啤酒，这两种毫无关系的商品为什么会被一起购买呢？\n沃尔玛经过分析后发现，美国的家庭主妇们经常会让她们的丈夫在回家的路上顺道买一些尿布给孩子用，而这些丈夫们辛苦工作了一天也想犒劳一下自己，于是在买尿布之余也给捎带上了自己最爱的啤酒。这就是著名的啤酒与尿布的故事。\n研究“啤酒与尿布”的关联分析方法就是购物篮分析，购物篮分析可以帮助商店在销售过程中，找到具有关联关系的商品，以此获得销售量的增长。\nApriori算法就是用来挖掘关联规则的最经典的算法。\n2. 算法介绍 在介绍算法之前，首先介绍几个概念\n 支持度(Support)  $$ Support(X, Y) = \\frac{num(XY)}{num(All)} = \\frac{含有X,Y物品的数据数量}{数据总数} $$\n通过支持度我们可以计算频繁项目集。\n置信度(confidence)  $$ Conf(X =\u0026gt; Y) = P(Y | X) = \\frac{XY}{X}$$\n形象的可以理解为购买了商品X之后，购买商品Y的概率。\n通过置信度我们可以来计算关联规则。\n频繁k项目集  满足支持度的商品的集合，这个集合中正好有k件商品\n3. 算法示例 Apriori算法的目的就是最大频繁项目集，举个例子，如果我们有下面的购物记录。\n   ID 购买商品     1 棒棒糖,啤酒,雪碧   2 啤酒，尿布，可乐   3 棒棒糖,尿布,啤酒,可乐   4 尿布,可乐    我们假设支持度为50%。\n我们取所有商品的种类可以得到一阶频繁项目集候选集合，一阶频繁项目集候选集合如下所示：\n[[\u0026lsquo;棒棒糖\u0026rsquo;], [\u0026lsquo;可乐\u0026rsquo;], [\u0026lsquo;尿布\u0026rsquo;], [\u0026lsquo;啤酒\u0026rsquo;], [\u0026lsquo;雪碧\u0026rsquo;]]\n接下来我们统计所有候选集合出现的次数:\n   购买商品 出现次数     棒棒糖 2   可乐 3   尿布 3   啤酒 3   雪碧 1    我们删去小于支持度的项目集合，由于支持度为50%，所以我们删除出现次数小于向下取整[数据总数×支持度]=int(5*0.5)=2的数据，最后我们可以得到我们的频繁1项目集，如下所示：\n   购买商品 出现次数     棒棒糖 2   可乐 3   尿布 3   啤酒 3    然后我们生成频繁2项集合的候选集，生成的方式很简单，就是将1阶频繁项目集合的商品两两合并即可，频繁2项集候选集如下所示。\n[[\u0026lsquo;可乐\u0026rsquo;, \u0026lsquo;尿布\u0026rsquo;], [\u0026lsquo;可乐\u0026rsquo;, \u0026lsquo;棒棒糖\u0026rsquo;], [\u0026lsquo;可乐\u0026rsquo;, \u0026lsquo;啤酒\u0026rsquo;], [\u0026lsquo;尿布\u0026rsquo;, \u0026lsquo;棒棒 糖\u0026rsquo;], [\u0026lsquo;啤酒\u0026rsquo;, \u0026lsquo;尿布\u0026rsquo;], [\u0026lsquo;啤酒\u0026rsquo;, \u0026lsquo;棒棒糖\u0026rsquo;]]\n接下来我们统计频繁2项集候选集中每个商品组合出现的次数，结果如下所示：\n   购买商品 出现次数     可乐,尿布 3   可乐,棒棒糖 1   可乐,啤酒 2   尿布,棒棒糖 1   啤酒,尿布 2   啤酒,棒棒糖 2    我们删去小于支持度的项目集合，由于支持度为50%，所以我们删除出现次数2的数据，最后我们可以得到我们的频繁2项目集，如下所示：\n   购买商品 出现次数     可乐,尿布 3   可乐,啤酒 2   啤酒,尿布 2   啤酒,棒棒糖 2    然后我们生成频繁3项集合的候选集，就是将2阶频繁项目集合的商品两两合并即可，频繁3项集候选集如下所示。 .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Tip\n这里需要保证两个2阶频繁项目集合的商品，合成之后刚好为3个商品。\n例如[可乐,尿布]和[可乐,啤酒]可以合成为[可乐,尿布,,啤酒]\n但是[可乐,尿布]和[啤酒,棒棒糖]不可以合成为[可乐,尿布,啤酒,棒棒糖]\n 所以频繁3项集合的候选集有\n[[\u0026lsquo;可乐\u0026rsquo;, \u0026lsquo;啤酒\u0026rsquo;, \u0026lsquo;尿布\u0026rsquo;], [\u0026lsquo;可乐\u0026rsquo;, \u0026lsquo;啤酒\u0026rsquo;, \u0026lsquo;棒棒糖\u0026rsquo;], [\u0026lsquo;啤酒\u0026rsquo;, \u0026lsquo;尿布\u0026rsquo;, \u0026lsquo;棒棒糖\u0026rsquo;]]\n接下来我们统计频繁3项集候选集中每个商品组合出现的次数，结果如下所示：\n   购买商品 出现次数     可乐,啤酒,尿布 2   可乐,啤酒,棒棒糖 1   啤酒,尿布,棒棒糖 1    通过支持度过滤，最后可得频繁3项集合为：\n   购买商品 出现次数     可乐,啤酒,尿布 2    4. 算法核心  任何一个频繁项集的子集必是频繁项集  {西瓜、冬瓜、南瓜}是频繁项集 $=\\gt$ {西瓜、冬瓜}是频繁项集\n如果一个集合是不频繁的，其超集必然是不频繁的  {牛奶}不是频繁项集 $=\\gt$ {牛奶、鸡蛋}不是频繁项集\n5. 算法实现 算法流程\n 初始化i = 1 计算数据的频繁i项集的候选集 计算候选集出现的次数 通过支持度得到频繁i项集，i++ 如果频繁i项集为空，算法结束，否则重复2-5步  本次算法实现采用Python和Go语言分别进行实现。（由于笔者最近在学习Go语言，所以也使用Go语言进行实现了一遍）\n5.1 Python实现 # 得到所有种类 def get_set(data): s = set() for row in data: s = s | row return [[k] for k in s] # 判断项集是否在数据库data中 def isin(items, row): for x in items: if x not in row: return False return True # 发现频繁项目集 def find_frequent(data, compose_data): res = {} # 初始化频繁项集 for t in compose_data: res[\u0026quot;,\u0026quot;.join(t)] = 0 # 项集去重 # 遍历数据库计算所有项集出现的次数 for row in data: for items in compose_data: if isin(items,row): res[\u0026quot;,\u0026quot;.join(items)] += 1 print(res) # 删除小于支持度的项集 for k in list(res.keys()): if res[k] \u0026lt; conf_length: del res[k] return res def merge(a, b): res = {} return_list = [] for x in a: res[x] = True for x in b: res[x] = True for k in res.keys(): return_list.append(k) sorted(return_list) return return_list # 交叉生成下一阶段备选的频繁项集 def compose(set_data,level = 2): set_key_data = [k.split(\u0026quot;,\u0026quot;) for k in set_data.keys()] compose_data = list() for i in range(len(set_key_data)): for j in range(i+1,len(set_key_data)): tmp = merge(set_key_data[i],set_key_data[j]) if len(tmp) == level: tmp.sort() compose_data.append(tmp) # 去重复 res = {} re_compose_data = [] for x in compose_data: res[\u0026quot;,\u0026quot;.join(x)] = True compose_data = [k.split(\u0026quot;,\u0026quot;) for k in res.keys()] return list(compose_data) # 数据库数据 data = [ {\u0026quot;棒棒糖\u0026quot;,\u0026quot;啤酒\u0026quot;,\u0026quot;雪碧\u0026quot;}, {\u0026quot;尿布\u0026quot;,\u0026quot;啤酒\u0026quot;,\u0026quot;可乐\u0026quot;}, {\u0026quot;棒棒糖\u0026quot;,\u0026quot;尿布\u0026quot;,\u0026quot;啤酒\u0026quot;,\u0026quot;可乐\u0026quot;}, {\u0026quot;尿布\u0026quot;,\u0026quot;可乐\u0026quot;}, ] # 支持度 CONF = 0.5 conf_length = int(len(data) * CONF) compose_data = get_set(data) i = 2 while compose_data: print(compose_data) frequent = find_frequent(data,compose_data) print(f\u0026quot;第{i-1}频繁项集为:\u0026quot;,frequent) compose_data = compose(frequent,i) i+=1  5.2 Go语言实现 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;strings\u0026quot; \u0026quot;sort\u0026quot; ) func get_set(data [][]string) [][]string { set := make(map[string]bool) for _, row := range data { for _, x := range row { set[x] = true } } var return_list [][]string for index, _ := range set { var index_list []string index_list = append(index_list,index) return_list = append(return_list,index_list) } return return_list } func isin(items []string, row []string) bool { // items 一个项集，row 一行数据 for _, x := range items{ flag := 1 for _, x_row := range row{ if x == x_row{ flag = 0 break } } if flag == 1 { return false } } return true } //发现频繁项集 func find_frequent(data [][]string, compose_data [][]string, conf_length int) map[string]int { res := make(map[string]int) flag := make(map[string]int) var key_compose [][]string // 项集去重 for _, items := range compose_data { str_itmes := strings.Join(items,\u0026quot;,\u0026quot;) res[str_itmes] = 0 flag[str_itmes] += 1 if flag[str_itmes] == 1{ key_compose = append(key_compose,items) } } // 计算每个项集的次数 for _, row := range data { for _, items := range key_compose { if isin(items,row) { res[strings.Join(items,\u0026quot;,\u0026quot;)] += 1 } } } res2 := make(map[string]int) for k, v := range res{ if v \u0026gt;= conf_length { res2[k] = v } } return res2 } func merge(a []string, b []string) []string { res := make(map[string]bool) var return_list []string for _, x := range a { res[x] = true } for _, x := range b { res[x] = true } for k, _ := range res { return_list = append(return_list,k) } sort.Strings(return_list) return return_list } func compose(set_data map[string]int, level int) [][]string{ var set_key_data, compose_data [][]string for k, _ := range set_data { parts := strings.Split(k,\u0026quot;,\u0026quot;) set_key_data = append(set_key_data, parts) } // 接下来进合并操作 for i1 , i := range set_key_data{ for i2 , j := range set_key_data { if i2 \u0026gt; i1 { // 合并两个集合 tmp := merge(i,j) if len(tmp) == level { compose_data = append(compose_data,tmp) } } } } return compose_data } func main() { data := [][]string{ []string{\u0026quot;棒棒糖\u0026quot;,\u0026quot;啤酒\u0026quot;,\u0026quot;雪碧\u0026quot;}, []string{\u0026quot;尿布\u0026quot;,\u0026quot;啤酒\u0026quot;,\u0026quot;可乐\u0026quot;}, []string{\u0026quot;棒棒糖\u0026quot;,\u0026quot;尿布\u0026quot;,\u0026quot;啤酒\u0026quot;,\u0026quot;可乐\u0026quot;}, []string{\u0026quot;尿布\u0026quot;,\u0026quot;可乐\u0026quot;}, } // 支持度 var CONF float32 = 0.5 var conf_length int = int(CONF * float32(len(data))) // 获得所有样本的种类 compose_data := get_set(data) for i := 2; ; i++{ // 发现频繁项目集 frequent := find_frequent(data,compose_data,conf_length) compose_data = compose(frequent,i) if len(frequent) != 0 { fmt.Printf(\u0026quot;第%d阶频繁项目集为%v\\n\u0026quot;,i - 1,frequent) } else { break } } }  Tip\nGo语言实现实在是太费劲了，竟然不允许float和int数据之间做加法，呜呜呜~\n欢迎大家吐嘈代码。\n 参考视频  理论讲解 手写过程  ","id":5,"section":"posts","summary":"Apriori算法是经典的数据关联规则的算法，接下来让我们一起回顾Apriori算法吧！ 1. 算法背景 在沃尔玛超市中，商店人员发现购买尿布的人往","tags":null,"title":"回顾Aprioir算法","uri":"https://coder-liuu.github.io/2021/08/review-aprioir/","year":"2021"},{"content":" 如果问你为什么要学习数学，你回答“处理数字”，那么如果问你为什么要学习音乐，你的回答会是“处理音符“吗？\n 1. 什么是梯度? 分析:辅导视频\n答：首先梯度是一个矢量，表示函数在该点处沿着梯度的方向变化最快，变化率为梯度的大小。比如对于二元函数$z=f(x,y)$，在平面区域D具有一阶连续偏导数。某点的梯度为:\n\\[ 某点梯度 = \\frac{\\partial Z}{\\partial Y} + \\frac{\\partial Z}{\\partial X}\\]\n形象的可以理解为跑向山顶最快的方向。\n2. 什么是极大似然估计? 分析: 辅导视频\n首先，概率密度函数用来描述随机变量取某个值时，取值点所对应的概率的函数。\n例如下面就是一个概率分布函数\n\\[ f(x; \\mu, \\sigma) = \\frac{1}{\\sigma \\sqrt{2 \\pi}} exp(-\\frac{(x - \\mu)^2}{2 \\sigma^2})\\]\n$x$是随机变量，$\\mu 和\\sigma$ 都是参数\n其次，明确概率和似然的区别\n 概率：是在已知一些概率分布参数的情况下，预测观测的结果。 似然：是在已之观测结果的情况下，对概率分布的参数进行估值。  极大似然估计的目的在于找到一个最符合当前观测数据的概率分布\n最后，进入正题，我们假设有一组观察到的数据，一共有N个，$X_{observation} = {x_1, x_2, ... , x_N}$我们将$X_observation$里的数据点带入到$f(x; \\mu, \\sigma)$里，得到每个数据点在我们假设概率分布中的出现的可能性。\n\\[P(x_1 | \\mu, \\sigma),P(x_2 | \\mu, \\sigma), ...,P(x_3 | \\mu, \\sigma)\\]\n那么这一组数据$X_{observation}$在概率分布中出现的可能性就是他们的乘积：\n\\[L(\\mu, \\sigma | X_{observation}) = P(X | \\mu, \\sigma) = \\prod_{i=1}^{N} P(x_i | \\mu, \\sigma)\\]\n上式中，我们用$L(\\mu, \\sigma | X_{observation}) $表示似然函数，通过已知的观测数据点X，用似然函数来估计参数$\\mu, \\sigma$的可能性。由此可见似然函数也是一种条件概率函数，但是我们关注的变量变了似然函数的值越大，参数拟合的越好。\n找到似然函数的极大值的过程就是极大似然估计的过程。\n接下来说一下对数似然函数(log likelihood)，我们对似然函数取对数，就是对数似然函数。\n\\[L(\\mu, \\sigma | X_{observation}) = \\sum_{i=1}^{N} log P(x_i | \\mu, \\sigma)\\]\n 原因1：如果不加对数，求导需要链式法则，十分困难。而对数似然函数求导十分方便。 原因2：如果不加对数，似然函数的值十分的小，太接近0了，而对数似然函数，把接近于0的数，变成很大的负数，方便计算。 原因3：对似然函数取对数，并不改变函数原来极大值的位置。  答：极大似然估计就是使用已观测数据，来计算其全部数据一起出现的概率，最终找到一组最符合当前观测数据分布的参数。通常我们要对似然函数取对数，来方便我们的计算。\n3. 什么是中心极限定理与大数定律? 分析：参考资料、辅导视频\n答：\n 中心极限定律是指:给定一个任意分布的总体，每次从总体中随机取出n个样本，一个抽取m次。把这m组样本分布求平均值，这些平均值的分布接近正太分布。 大数定律是指:在随机试验中，每次出现的结构不同，但是大量试验的结果的平均值总是接近某个确定的值。  大数定理揭示了大量随机变量的平均结果，但是没有涉及到随机变量的分布问题。而中心极限定律说明，大量独立随机变量的平均值是以正太分布为极限的。\n大数定律描述的是频率稳定性，而中心极限定理描述的是分布的稳定性。\n4. 什么是点估计，什么是矩估计？ 分析：参考资料\n答：\n 点估计：用样本来估计参数值为点估计，如果估计的是参数的一个区间则为区间估计。\n 矩估计：用样本矩来替换总体距，例如使用样本均值估计总体均值$/mu$。(参考资料的30页)\n  5. 什么是矩阵的秩？ 分析：参考视频\n答：K阶子式不为0,K+1阶子式全为0,则矩阵的秩为k。几何意义就是经过线性变化后空间的维度，矩阵的秩就是矩阵中最精简的信息的多少。\n6. 矩阵乘以向量的意义是什么？ 分析：参考视频\n答：一个矩阵右乘一个向量，相当与对该向量做一个特定的线性变化，例如下面这个等式:\n\\[ \\left[ \\begin{matrix} a \u0026 b \\\\ c \u0026 d \\end{matrix} \\right] * \\left[ \\begin{matrix} x \\\\ y \\end{matrix} \\right] = x \\hat{i} + y \\hat{j} = x \\left[ \\begin{matrix} a \\\\ c \\end{matrix} \\right] + y \\left[ \\begin{matrix} b \\\\ d \\end{matrix} \\right] = \\left[ \\begin{matrix} ax+by \\\\ cx+dy \\end{matrix} \\right] \\]\n下面这个等式的意思是，对于一个二维空间上的向量，开始时基向量\\(i=\\left[ \\begin{matrix} 1 \\\\ 0 \\end{matrix} \\right]，j=\\left[ \\begin{matrix} 0 \\\\ 1 \\end{matrix} \\right]\\)经过一个线性变化后，基向量\\(i=\\left[ \\begin{matrix} a \\\\ c \\end{matrix} \\right]，j=\\left[ \\begin{matrix} b \\\\ d \\end{matrix} \\right]\\)后原本空间中的向量\\(\\left[ \\begin{matrix} x \\\\ y \\end{matrix} \\right]\\)，将会变成\\( \\left[ \\begin{matrix} ax+by \\\\ cx+dy \\end{matrix} \\right]\\)，所以说矩阵右乘一个向量相当与对向量作一个线性变换。\n如果说一个矩阵乘以一个矩阵的意义是什么，则可以理解为两次线性变化的复合。\n7. 行列式的意义： 分析：参考视频\n答：通过线性变换之后空间中物体变换的大小（二维是面积，三维是体积）。例如行列式\\( \\left[ \\begin{matrix} 2 \u0026 0 \\\\ 0 \u0026 3 \\end{matrix} \\right] = 6\\)表示通过这个线性变换，空间中的所有物体的面积将会增加6倍。行列式为0说明整个空间被压缩到了一条线上。\n扩展：证明公式|A||B|=|AB|？\n答：|A|表示经过线性变换A后基向量所围成的面积，|B|表示经过线性变换B后基向量所围成的面积。|A||B|表示基向量通过线性变换A会有一个面积det(A) = S，然后在对S倍的基向量进行线性变换B会得到一个面积。而|AB|表示基向量先经过线性变化A，然后在经过线性变化B后所围成的面积。其中两者都是在普通空间对面积为|A|图形做一个线性变化B，所有变换之后的面积是相等的。\n8. 矩阵的逆是什么： 分析：参考视频\n答：矩阵的逆的定义是:$ A*A^{-1}=E$ 则称$A^{-1}$是矩阵A的逆 ，从线性变量的角度来看就是原空间可以通过线性变换A进行变换到空间B，然后通过线性变换$A^{-1}$可以将空间B变换到原来的空间。\n.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Tip\n下面的东西，是一些流水帐，建议读者止步!\n 其他 1. 大数据带来的思维方式的三个转变是： 全样而非抽样，效率而非精确，相关而非因果\n全样而非抽样：人们处理的数据从样本数据变成全部数据;\n效率而非精确：由于是全样本数据，人们不得不接受数据的混杂性，而放弃对精确性的追求\n相关而非因果：人类通过对大数据的处理，放弃对因果关系的渴求，转而关注相关关系\n2. 大数据的4V特性 数据量大，种类多，价值密度低，处理速度快\n3. Apriori算法 核心思想：\n 任何一个频繁项集的子集必是频繁项集 {西瓜、冬瓜、南瓜}是频繁项集 =\u0026gt; {西瓜、冬瓜}是频繁项集\n 如果一个集合是不频繁的，其超集必然是不频繁的 {牛奶}不是频繁项集 =\u0026gt; {牛奶、鸡蛋}不是频繁项集\n  辅导视频\n4. 数据挖掘分析常用的方法 分类，聚类，关联规则挖掘，时间序列分析，异常点挖掘\n5. 数据挖掘的步骤 问题定义、数据获取、数据清洗、特征选择、模型建立、模型评估\n6. Hadoop特性  具有很高的可靠性，多台机器构成集群，部分机器发生故障，剩余机器可以继续对外提供服务 具有很高高效性，成百上千台机器一起计算，作为一个整体来分布式并行处理，所以它可以非常高效地处理海量分布式数据集 具有很好的可扩展性，在一个Hadoop集群里，可以不断的往集群中增加机器 成本低，Hadoop可以采用普通PC机来构成一个集群 支持多种语言来完成Hadoop应用程序的开发 运行在linux平台上 高容错性 具有数据副本，不宜出错  7. 单机模式和伪分布模式的异同点 相同点：实际上都是在一台主机，Hadoop的功能一致\n不同点：单击模式Hadoop没有守护进程，伪分布式是在一台主机上模拟多台主机。\n8. Hadoop知识点 Hadoop的核心就是分布式文件系统HDFS和分布式编程计算MapReduce\nHbase是分布式数据库\nSpark内存计算\n9. 试述HDFS中的名称节点和数据节点的具体功能。 名称节点简单来说最主要的功能就是:名称节点记录了每个文件中各个块所在数据节点的位置信息\n名称节点的所有功能: 1. 存储元数据 2. 元数据保存在内存中 3. 保存文件block,datanode之间的映射关系\n数据节点的所有功能:1. 存储文件内容 2.文件内容保存在磁盘中 3. 维护了block id 到 datanode 本地文件的映射关系\n10. 试述HDFS的冗余数据保存策略。  第一个副本：放置在上传文件的数据节点 第二个副本：放置在与第一个副本不同的机架的节点上 第三个副本：与第一个副本相同机架的其他节点上  11. 试述HDFS是如何探测错误发生以及如何进行恢复的。  如果名称节点出错，整个HDFS实例将失效  HDFS设置了备份机制，把这些核心文件同步复制到备份服务器SecondaryNameNode上。当名称节点出错时，就可以根据备份服务器SecondaryNameNode中的FsImage和Editlog数据进行恢复。\n探测数据节点出错和恢复措施  每个数据节点会定期向名称节点发送“心跳”信息，向名称节点报告自己的状态。\n恢复：而名称节点一旦发现某个数据块的副本数量小于冗余因子，就会启动数据冗余复制，为它生成新的副本。\n探测数据出错和恢复措施  使用校验码进行校验\n客户端在读取到数据后，会对数据块进行校验，以确定读取到正确的数据。在文件被创建时，客户端就会对每一个文件块进行信息摘录，并把这些信息写入到同一个路径的隐藏文件里面。\n当客户端读取文件的时候，会先读取该信息文件，然后，利用该信息文件对每个读取的数据块进行校验，如果校验出错，客户端就会请求到另外一个数据节点读取该文件块，并且向名称节点报告这个文件块有错误，名称节点会定期检查并且重新复制这个块。\nHBase习题  HBase 是列式数据库，不是关系数据库\n get:通过表名、行、列、时间戳、时间范围和版本号来获得相应单元格的值\n HBase三级寻址 ZooKeeper文件，ROOT表，META表 $=\\gt$ 用户数据\n  计算机网络 1. TCP三次握手  主机A -\u0026gt; (SYN) 主机B 主机A \u0026lt;- (ACK) 主机B 主机A -\u0026gt; ACK 主机B  2. 四次挥手  主机A -\u0026gt; (FIN) 主机B 主机A \u0026lt;- (ACK) 主机B 主机A \u0026lt;- (FIN) 主机B 主机A -\u0026gt; (ACK) 主机B  计算机组成原理 常见问题链接\nKruskal和prim算法的大致过程 Kruskal算法(时间复杂度ElogE,E边数):\n 对所有边进行排序 不断挑一个最小权重的边进行判断 如果不连通，加入这条边。如果联通，不加入 直到有顶点减一条边  Prim算法(NN,N点数)：\n 随机选取一个点 选择离他最近的点，然后加上边 不断选择距离最近的点，然后加上边  哈密顿图和欧拉图定义 哈密顿图:每个点只经过一次\n欧拉图:每个边只经过一次\n怎么判断链表有环 快慢指针，一个指针走一步，一个指针走两步，看会不会相遇\n在什么情况下，极值就是最值？ 当函数有唯一极值时，极值就是最值。\n源码，反码，补码之间的关系？ 正数:源码=反码=补码\n负数:源码, 反码=源码(除符号位之外,全部数字取反),补码=反码+1\n泰勒公式意义 如何在x0点附近，使用一个多项式函数去近似一个复杂函数\n什么是极大无关组? 对于向量组A来说，选择r个向量组成向量组$A_{0}$满足，r个向量线性无关，r+1个向量线性相关，则称向量$A_{0}$是向量组A的一个极大线性无关组。\n说说条件概率、全概率公式、贝叶斯公式？ 参考资料\n条件概率：$P(A|B) = \\frac{P(A \\cap B)}{P(B)}$ 意义为：添加一个条件后，事件发生的概率。\n全概率公式：$P(C) = \\sum_{i}^{n} p(L_i)P(C|L_i)$ 意义为：达到某个目的有多种方式，为到达目的的概率是多少？\n贝叶斯公式：$P(L_k | C) = \\frac{P(C | L_k) P(L_k)}{P(C)}$ 意义为：当已知结果后，问导致该结果的第i原因是的可能性是多少？\n操作系统的调度算法？  先来先服务 短作业优先 时间片论转  ","id":6,"section":"posts","summary":"如果问你为什么要学习数学，你回答“处理数字”，那么如果问你为什么要学习音乐，你的回答会是“处理音符“吗？ 1. 什么是梯度? 分析:辅导视频 答：首先","tags":null,"title":"机器学习中的数学笔记","uri":"https://coder-liuu.github.io/2021/08/ml-interview/","year":"2021"},{"content":" 还在苦恼一个U盘只能作为一个系统盘吗？不如试试Ventoy\n 1. 问题来源 在很早之前我一直使用Rufus来制作启动盘，但是其有个很大的问题，一个U盘只能制作一个系统盘。导致如果我想安装多个系统，只能需要多个U盘了。\n2. Ventoy工具 2.1 介绍 Ventoy正是解决该问题的利器，优点：\n 可以用来多个系统 可以存放其他文件(但是不太推荐) 这个软件不仅Windows还支持Linux，非常Nice。  2.2 使用方法 第一，我们必须先要安装该软件。点我出发去下载\n.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Tip\n注意由于Github可能下载过慢，官网中还有使用Gitee等其他下载方式进行下载。\n 第二，就是制作Ventoy盘了，启动刚刚下载的程序，然后先不要着急点制作\n注意右上角有个配置选项， 配置选项一定要选择安全启动支持，分区类型选择GPT。否则后面U盘启动会一直黑屏(我是这样的)。接下来点击制作。\n第三，打开我们的U盘，可以看到我们的U盘里面变得空空了。我们只需要往里面放你想安装的系统即可。\n最后，插上U盘使用U盘启动即可。\n2.3 主题 默认的Ventoy的主题还行，如果你觉得不好看，你可以进行主题的更换，不过有点折腾不太推荐。具体步骤如下所示：\n第一步，去这个网站来进行挑选主题，挑选好点击Files，然后有一个下载的图标，点击即可下载。\n第二步，解压文件，进入唯一的文件夹，一般都是下图这个样子。复制来替换VTOYEFI分区中的grub/themes/中的全部文件(通常VTOYEFI分区在Windows下会被隐藏，不过可以使用DiskGenius进行查看)。如果还是不明白，可以参考参考文献中视频2进行操作\n 第三步，你会发现主题没有图标，呜呜呜，需要再写一个ventoy.json文件才可以，这个文件需要放在放镜像的分区中的ventoy文件夹下(需要自己来创建文件夹)，具体的官网说明点我出发。如果你太懒不想自己写文件，可以使用具有json文件的主题，哒哒哒，就是他。\n最后，插上U盘启动即可。\n3. 参考文献   颠覆你对于U盘启动的认知！——Ventoy\n  一个超级好用的U盘引导启动工具-Ventoy 一个U盘即可制作多个系统启动盘\n  ","id":7,"section":"posts","summary":"还在苦恼一个U盘只能作为一个系统盘吗？不如试试Ventoy 1. 问题来源 在很早之前我一直使用Rufus来制作启动盘，但是其有个很大的问题，一个U","tags":null,"title":"启动盘神器Ventoy","uri":"https://coder-liuu.github.io/2021/07/ventoy-tuition/","year":"2021"},{"content":" 机器学习竞赛赛题，常见的结构性数据比赛\n 一、题目简介   赛题背景:在一家保险公司里，通过保险公司的数据，预测一个人是否会对保险感兴趣。\n  数据示例:    评价指标：AUC\n  二、赛题步骤 2.0 完整型判断   检测重复值 df_data.duplicated().sum()\n  检测列缺失值 df_data.isnull().sum(axis=0)\n  2.1 数据探索  探索离散值分布的常用代码。  columns_list = [\u0026quot;Gender\u0026quot;,\u0026quot;Driving_License\u0026quot;,\u0026quot;Previously_Insured\u0026quot;,\u0026quot;Vehicle_Damage\u0026quot;,\u0026quot;Vehicle_Age\u0026quot;,\u0026quot;Response\u0026quot;] plt.figure(figsize=(10,5)) for id_,x in enumerate(columns_list): plt.subplot(2,3,id_+1) # 这里注意我有6个属性，所以是2×3的子图 sns.countplot(data=df_data,x=x) plt.tight_layout()    效果图     探索连续值分布的常用代码  plt.figure(figsize=(12,8)) x_list = [\u0026quot;Age\u0026quot;,\u0026quot;Region_Code\u0026quot;,\u0026quot;Annual_Premium\u0026quot;,\u0026quot;Policy_Sales_Channel\u0026quot;,\u0026quot;Vintage\u0026quot;] for id_,x in enumerate(x_list): plt.subplot(5,1,id_+1) # 子图的大小和特征个数有关系 sns.distplot(df_data[x],kde=True) plt.tight_layout()    效果图    2.2 离散值编码 数据中，具有一些字符串的离散值，如果离散值比较少，比如\u0026quot;男\u0026quot;和\u0026quot;女\u0026quot;，我们应该使用标号编码进行映射到数值区间。\n对于地区代码属性，其具有非常多的离散属性，我们可以使用目标编码进行编码，映射到一定的数值区间\n目标编码简单可以理解为，将每个地区代码映射为其所在地区的人对保险感兴趣的平均值。\n具体代码如下所示:\n# 标号编码 data[\u0026quot;Gender\u0026quot;] = data[\u0026quot;Gender\u0026quot;].map({\u0026quot;Male\u0026quot;:1, \u0026quot;Female\u0026quot;:0}) data[\u0026quot;Vehicle_Age\u0026quot;] = data[\u0026quot;Vehicle_Age\u0026quot;].map({\u0026quot;\u0026lt; 1 Year\u0026quot;:0,\u0026quot;1-2 Year\u0026quot;:1,\u0026quot;\u0026gt; 2 Years\u0026quot;:2}) data[\u0026quot;Vehicle_Damage\u0026quot;] = data[\u0026quot;Vehicle_Damage\u0026quot;].map({\u0026quot;Yes\u0026quot;:1,\u0026quot;No\u0026quot;:0}) # 目标编码，通过一个类可以更方便的实现 from sklearn.base import BaseEstimator, TransformerMixin class TargetEncoderTrain(BaseEstimator, TransformerMixin): def __init__(self, col, tar): self.col= col self.tar= tar self.discardOriginal_col = discardOriginal_col def fit(self, X): self.tar_mean = X[self.tar].mean() self.map = X.groupby(self.col)[self.tar].mean() return self def transform(self,X): col = self.col X[col] = X[col].map(self.map) X[col].fillna(self.tar_mean) return X et = TargetEncoderTrain(\u0026quot;Region_Code\u0026quot;,\u0026quot;Response\u0026quot;) train_data = pd.concat([x_train,y_train],axis=1) x_train[col] = et.fit_transform(train_data)[col] x_val[col] = et.transform(x_val)[col]  2.3 特征之间相关性分析 corr = df_data.corr() plt.figure(figsize=(16,10)) sns.heatmap(corr,annot=True,cmap=\u0026quot;Purples\u0026quot;)    效果图    这里我们可以去掉相关性非常小的特征，以便提高模型的性能。\n2.4 寻找基础模型 下面列出了多种常用模型，以便分析性能\nfrom sklearn.neighbors import KNeighborsClassifier from sklearn.linear_model import LogisticRegression from sklearn.tree import DecisionTreeClassifier from sklearn.ensemble import GradientBoostingClassifier from sklearn.ensemble import AdaBoostClassifier from sklearn.ensemble import RandomForestClassifier from sklearn.discriminant_analysis import LinearDiscriminantAnalysis from sklearn.naive_bayes import GaussianNB from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis from xgboost import XGBClassifier from lightgbm import LGBMClassifier from sklearn.metrics import roc_auc_score clf_list = { \u0026quot;KNN\u0026quot;:KNeighborsClassifier(), \u0026quot;CART\u0026quot;:DecisionTreeClassifier(), \u0026quot;LDA\u0026quot;:LinearDiscriminantAnalysis(), \u0026quot;QDA\u0026quot;:QuadraticDiscriminantAnalysis(), \u0026quot;LR\u0026quot;:LogisticRegression(), \u0026quot;Ga\u0026quot;:GaussianNB(), \u0026quot;GBDT\u0026quot;:GradientBoostingClassifier(), \u0026quot;Adaboost\u0026quot;:AdaBoostClassifier(), \u0026quot;RF\u0026quot;: RandomForestClassifier(), \u0026quot;XGboost\u0026quot;: XGBClassifier(), \u0026quot;LGBM\u0026quot;: LGBMClassifier(), } score_list = list() for name,clf in clf_list.items(): clf.fit(x_train,y_train) y1 = clf.predict_proba(x_val)[:,1].flatten() score = roc_auc_score(y_val,y1) print(name,score,end=\u0026quot;\\n\\n\u0026quot;)  .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Tip\n不过，通常来说，都是XGBoost或者是LGBM分类器效果好一些。\n 2.4 模型调参 模型调参是一个体力劳动，但是拥有好工具，可以让你事半公倍。好工具就是hyperopt库了\n调参实例代码\nfrom hyperopt import fmin, tpe, hp, Trials, space_eval # 定义参数空间 param_space = {'max_depth': hp.choice('max_depth', range(4, 9, 1)), 'reg_lambda': hp.uniform('reg_lambda', 0.0, 1.0), 'learning_rate' : hp.quniform('learning_rate', 0.1, 0.5, 0.1), 'n_estimators' : hp.choice('n_estimators', range(50, 250, 30)), 'num_leaves': hp.choice('num_leaves',[15, 31, 63, 127]), 'subsample': hp.choice('subsample',[0.6, 0.7, 0.8, 1.0]), 'colsample_bytree': hp.choice('colsample_bytree',[0.6, 0.7, 0.8, 1.0]),} # 定义评判函数，调参机器认为返回值越小越好，所以返回1-AUC def objective_lgbm(params): x_train,x_val,y_train,y_val = train_test_split(train,labels,test_size=0.1,random_state=0,stratify=labels) x_train,x_val,y_train, = target_labels(x_train,x_val,y_train) clf = LGBMClassifier(**params) clf.fit(x_train,y_train) y1 = clf.predict_proba(x_val)[:,1].flatten() score = roc_auc_score(y_val,y1) return 1 - score # 八股文代码 trials = Trials() best = fmin(fn=objective_lgbm, space=param_space, max_evals=10, # 迭代的次数 rstate=np.random.RandomState(0), algo=tpe.suggest, trials=trials ) # 查看最佳代码 best_params = space_eval(param_space, best) print(\u0026quot;最佳参数:\u0026quot;,best_params) # 之后直接创建最佳模型 clf = LGBMClassifier(**best_params)  这段代码的通用性很强，复用只需要修改参数空间和评判函数就可以了\n 如需完整代码，请见点我出发\n ","id":8,"section":"posts","summary":"机器学习竞赛赛题，常见的结构性数据比赛 一、题目简介 赛题背景:在一家保险公司里，通过保险公司的数据，预测一个人是否会对保险感兴趣。 数据示例: 评","tags":null,"title":"健康保险的客户投保预测","uri":"https://coder-liuu.github.io/2021/07/health-insure-predict/","year":"2021"},{"content":"Oh，好久不更新，接下来说一说我最近的在做的其中的一个事情吧～\n 问题描述: 给我2000张带噪音的手写数字图片，如下图所示。要求我训练一个模型，使其能在测试集10000张带噪音的手写数字图片，取得较好的效果。\n    噪声图片   一、图片预处理 通过分析可以知道这是高斯噪音，高斯噪音的形成为：一个正太分布的随机数与原图相加，即可使图片拥有高斯噪音。\n添加高斯噪音的Python代码为：\ndef add_gaussian_noise(image_in, noise_sigma): temp_image = np.float64(np.copy(image_in)) h, w = temp_image.shape noise = np.random.randn(h, w) * noise_sigma noisy_image = np.zeros(temp_image.shape, np.float64) noisy_image = temp_image + noise return noisy_image  添加效果如下所示:\n   左边原图，右边加噪音图   消除高斯噪音，我有两种思路。\n 直接对图片二值化(大于0.4的像素点为1,小于0.4的像素点为0)，下面是效果图。     左边噪音图，右边二值化   使用高斯滤波之后，做一个简单的去背景噪声，使用高斯滤波器核心代码cv2.GaussianBlur(noise,(3,3),0)，下面是效果。     左边噪音图，右边效果图   二、数据增强 数据增强有一个非常好使的库，名字为imgaug，接下来我说一下基本用法吧。\nfrom imgaug import augmenters as iaa # 导入库 iaa.Affine(rotate=(-15, 15)), # 定义增强方式 img_aug = aug.augment_images(img) # 进行数据增强  只需三行，方可入手。超级简单有么有～。如果需要查看更多增强方式，请看这个博客，讲的非常详细。\n三、搭建模型 对于自己瞎玩可以随便搭建模型，但是这是一个比赛，可需要认真一点了。Kaggle上曾有人证明最优28×28的网络的形状，详细过程可以参考这篇博客，这里我直接说结论了，下图是Tensorflow代码，易读性很器的。\nmodel = Sequential([ Conv2D(32, kernel_size = 3, activation='relu', input_shape = (28, 28, 1)), BatchNormalization(), Conv2D(32, kernel_size = 3, activation='relu'), BatchNormalization(), Conv2D(32, kernel_size = 5, strides=2, padding='same', activation='relu'), BatchNormalization(), Dropout(0.4), Conv2D(64, kernel_size = 3, activation='relu'), BatchNormalization(), Conv2D(64, kernel_size = 3, activation='relu'), BatchNormalization(), Conv2D(64, kernel_size = 5, strides=2, padding='same', activation='relu'), BatchNormalization(), Dropout(0.4), Conv2D(128, kernel_size = 4, activation='relu'), BatchNormalization(), Flatten(), Dropout(0.4), Dense(10, activation='softmax'), ])  该模型三个特点:\n 连续使用2个3×3卷积层，增加了网络的判别能力。 使用卷积核为5,步长为2的卷积层代替池化层，增加的网络的性能。 使用批归一化层和Dropout层，防止模型过拟合的同时，增加了网络性能。  四、模型集成 老师说：团结就是力量，模型当然也是，一个CNN的力量有限的，这篇文章使用Bagging的训练的15个CNN进行集成，达到了前所未有的信高度，思路如下图所示：\n   CNN集成   对于该问题来说，同样如此，所以我训练了10个CNN进行集成。部分代码如下所示：\nnets = 10 model = [0] * nets for i in range(nets): model[i] = Sequential([...]) model[i].compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])  .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Tip\n全部代码公布在Kaggle上了，点击出发。\n 参考资料 https://www.kaggle.com/c/digit-recognizer/discussion/61480\n","id":9,"section":"posts","summary":"Oh，好久不更新，接下来说一说我最近的在做的其中的一个事情吧～ 问题描述: 给我2000张带噪音的手写数字图片，如下图所示。要求我训练一个模型，","tags":null,"title":"带噪音的手写数字识别","uri":"https://coder-liuu.github.io/2021/07/noise-mnist/","year":"2021"},{"content":" 大三下开学去考试，大三下结束才想起来写博客\u0026hellip;(捂脸)\n 本文不会谈任何的算法，只谈风景，因为自己考的实在是太垃圾了(呜呜呜)。\n前向图片高能预警~\n   网易      考点      清华      小路   ","id":10,"section":"posts","summary":"大三下开学去考试，大三下结束才想起来写博客\u0026hellip;(捂脸) 本文不会谈任何的算法，只谈风景，因为自己考的实在是太垃圾了(呜呜呜)。 前向","tags":null,"title":"北京CCF-CSP考试","uri":"https://coder-liuu.github.io/2021/07/album-ccf/","year":"2021"},{"content":"由于在论文中看到了GNN的东西，所以来简单记录一下。\nGNN？图神经网络，听起来很高大上的东西，简单来说可以提取图中每个点的特征。故其的作用为特征提取。本文到此结束，感谢您的阅读。\n基础知识-图  在计算机科学中，图是由顶点和边进行组成了一种结构。图G可以通过顶点集合V和边集合E来描述。\n 说人话就是：图可以用下面的图片来表示。\n 在图中，节点有：{男主，女主，宠物}，边为{喜欢，养}\n图神经网络GNN 图神经网络共有三个操作：聚合，更新，循环\n我们以分类问题为例，比如我们想判断上面一幅图中谁比较有钱。下面给出上面图中各个点的信息\n   属性 宠物 男主 女主     金钱 9999 9 900    Step1 聚合 对于普通的神经网络来说，我们很容易就知道宠物很有钱，但是通过图的关系来看，男主的宠物很有钱，也许可以推断出男主很有钱。\n所以男主的邻居信息N的计算公式如下所示: $$ N = a * (宠物的钱) + b * (女主的钱) $$\nStep2 更新 男主最终的特征为：\n$$ 男主钱 = \\sigma[ W * 男主自己的钱 + \\alpha N ] $$\n其中$\\sigma$是激活函数(比如relu或者sigma)\nW是模型的训练参数\nStep3 循环 通过一次聚合更新，我们可以推断出男主因为宠物很有钱，而变得有钱。\n接下来，我们进行第二次更新，女主就可以因为男主有有钱，而变得有钱。此时说明了女主也获得了其二阶邻居（男主宠物）的特征了。\n能干嘛？ Q: 最终怎么进行分类问题呢？\nA:我们通过GNN之后可以获得每个节点更新后的信息，也就是特征，此时我们就可以之间通过训练一个分类器来进行分类了。\n 归根到底，GNN就是一个特征分类的问题\n 怎么实现？ 手动写一个？不可能。我又不是专门研究这一个的，我们来看一下网上有的python库，我们可以通过这个库tf_geometric来实现图神经网络\n原始图的信息(5个节点，每个节点10个特征):\n图神经网络特征提取后的信息(5个节点，每个节点5个特征)\n为什么特征少了，我也想不出来，呜呜呜！\n参考链接 https://www.bilibili.com/video/BV1Tf4y1i7Go/?spm_id_from=333.788.recommend_more_video.-1\n","id":11,"section":"posts","summary":"由于在论文中看到了GNN的东西，所以来简单记录一下。 GNN？图神经网络，听起来很高大上的东西，简单来说可以提取图中每个点的特征。故其的作用为","tags":null,"title":"图神经网络GNN","uri":"https://coder-liuu.github.io/2021/06/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9Cgnn/","year":"2021"},{"content":"忽略警告 import warnings warnings.filterwarnings(\u0026quot;ignore\u0026quot;)  Numpy   取消科学技术法() np.set_printoptions(suppress=True)\n  保留3位有效数字 np.set_printoptions(precision=3)\n  数组扁平 data.flatten()\n  填充NAN a[np.isnan(a)]=1\n  判断一列是否有缺失值 np.isnan(data).any(axis=0)\n  判断一行是否有缺失值 np.isnan(data).any(axis=1)\n  Pandas   显示所有列 pd.set_option(\u0026lsquo;display.max_columns\u0026rsquo;, None)\n  显示所有行 pd.set_option(\u0026lsquo;display.max_rows\u0026rsquo;, None)\n  取消科学技术法 pd.set_option(\u0026lsquo;display.float_format\u0026rsquo;, lambda x: \u0026lsquo;%.3f\u0026rsquo; % x)\n  时间戳转正常时间 pd.to_datetime(时间戳 ,unit=\u0026lsquo;ms\u0026rsquo;) # ms是毫秒\n  分组求最大值所在行 .idxmax()\n  按某列排序 df.sort_values(by=\u0026ldquo;sales\u0026rdquo;,ascending=False)\n  每个样本多少次 value_counts()\n  按索引排序 sort_index()\n  重置索引 .reset_index()\n  按列统计缺失值 df.isna().sum()\n  获得一个分组 get_group(\u0026ldquo;分组名字\u0026rdquo;)\n  条件筛选 mask 满足条件赋值为指定值\n  描述数据 data.describe\n  Matplotlib   中文字体显示不出来 plt.rcParams[\u0026lsquo;font.sans-serif\u0026rsquo;]=[\u0026lsquo;Microsoft YaHei\u0026rsquo;]\n  图紧凑 plt.tight_layout()\n  加一条线\n  水平线 ax.axhline(y, linestyle='\u0026ndash;', color=\u0026lsquo;k\u0026rsquo;) #\n  垂直线 ax.axvline(x, linestyle='\u0026ndash;', color=\u0026lsquo;k\u0026rsquo;)\n    魔术命令\n magic有行魔法%time 和单元魔法%%time    坐标轴标签旋转 plt.xticks(rotation=50)\n  Sklearn  最大最小归一化 from sklearn.preprocessing import MinMaxScaler  范围参数 feature_range=(0, 1) 转化 fit_transform 反转化 inverse_transform    其他  ssh 验证失败  import ssl ssl._create_default_https_context = ssl._create_unverified_context  Excel  时间戳转日期 =TEXT((B2/1000+83600)/86400+70365+19,\u0026ldquo;yyyy-mm-dd hh:mm:ss\u0026rdquo;)  ","id":12,"section":"posts","summary":"忽略警告 import warnings warnings.filterwarnings(\u0026quot;ignore\u0026quot;) Numpy 取消科学技术法() np.set_printoptions(suppress=True) 保留3位有效数字 np.set_printoptions(precision=3) 数组扁平 data.flatten() 填充NAN a[np.isnan(a)]=1 判断一列是否有缺失值 np.isnan(data).any(axis=0) 判断一行是否有缺失值 np.isnan(data).any(axis=1) Pandas 显示所有列 pd.set_option(\u0026lsquo;display.max_columns\u0026rsquo;, None) 显示","tags":null,"title":"Python 常忘函数","uri":"https://coder-liuu.github.io/2021/05/python-forget-function/","year":"2021"},{"content":" 本文选择体积最小的Arch Linux作为Docker镜像开启全部过程,其他Linux发行版可能会有所区别\n 一、前期准备  使用该命令初始化pacman要不然pacman不能用  curl -fsSL \u0026quot;https://repo.archlinuxcn.org/x86_64/glibc-linux4-2.33-4-x86_64.pkg.tar.zst\u0026quot; | bsdtar -C / -xvf -  更换pacman的镜像源 这个过程不太容易，我发现Docker的Arch镜像什么编辑器也没有。于是我把自己电脑的nano编辑器传入Docker容器里面去了  然后手动编辑/etc/pacman.d/mirrorlist添加\nServer = https://mirrors.sjtug.sjtu.edu.cn/manjaro/stable/$repo/$arch  如果是Manjaro就简单了直接使用命令:pacman-mirrors -i -c China就可以了\n获取最新的包  pacman -Sy  安装前期准备的软件 配置Neovim肯定得安装一个Neovim吧，还需要下载东西的wget和git,最终命令如下所示:  pacman -S neovim wget git  二、配置NVim的核心功能 我认为Nvim的核心功能主要有下面几个部分\n  自动补全 目录树 主题   我们先创建一下Nvim的配置文件,命令mkdir -p ~/.config/nvim\n然后我们安装NVim的插件管理器，步骤如下:\n步骤1. 创建~/.config/nvim/autoload/plug.vim文件\n步骤2. 将Gist代码片段的内容复制进去\n2-1、自动补全的配置 关于自动补全可以选择的有很多，比如Ncm,COC,Kite等等许多\n本文使用Kite(一个基于人工智能的补全插件)来完成该功能\n步骤1. 下载Kite 命令为: bash -c \u0026quot;$(wget -q -O - https://linux.kite.com/dls/linux/current)\u0026quot;\n步骤2. 配置Kite 命令为\nmkdir -p ~/.config/nvim/pack/kite/start/kite git clone https://github.com/kiteco/vim-plugin.git ~/.config/nvim/pack/kite/start/kite/  如果没有代理的话，可以将上面的Github仓库替换成https://gitee.com/liu__yang/vim-plugin\n接下来，我将进行简单的配置这个插件，使用Nvim编辑~/.config/nvim/init.vim文件，然后加入下面的内容，我对内容添加了注释，保证通俗易懂。\n\u0026quot; 设置支持语言 Python, C++, Go let g:kite_supported_languages = ['python', 'cpp', 'go'] \u0026quot; Kite 状态条 set statusline=%\u0026lt;%f\\ %h%m%r%{kite#statusline()}%=%-14.(%l,%c%V%)\\ %P set laststatus=2 \u0026quot; always display the status line  .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Tip\n我加入的配置仅仅是最基本的配置，关于NVim使用Kite的全部文档可以在这里查看https://github.com/kiteco/vim-plugin\n 2-2、主题配置 使用Nvim编辑~/.config/nvim/init.vim文件，然后加入下面的内容\ncall plug#begin(\u0026quot;~/.vim-plug\u0026quot;) Plug 'connorholyday/vim-snazzy' call plug#end() let g:SnazzyTransparent = 1 color snazzy  解释一下:两个call之间是用来存储插件的，不可以放普通的配置\n最后执行:PlugInstall进行安装\n2-3、常规配置 使用Nvim编辑~/.config/nvim/init.vim文件，然后加入Gist代码片段的内容\n2-4、文件树的配置 使用Nvim编辑~/.config/nvim/init.vim文件，将下面的代码放在call plug#begin(\u0026quot;~/.vim-plug\u0026quot;)下面\nPlug 'preservim/nerdtree',{ 'on': 'NERDTreeToggle' }  然后两个call外添加按键映射，便可以使用T召唤出文件树来\nmap T :NERDTreeToggle\u0026lt;CR\u0026gt;  到此你的init.vim文件应该是这样的Gist代码片段\n到此Arch-Nvim1.0版本已经制作完毕，该Docker镜像发表在了我的Github中。\n三、后续优化 关于Neovim的插件有很多，下面我列举一些常用的插件，仅供选择。\n","id":13,"section":"posts","summary":"本文选择体积最小的Arch Linux作为Docker镜像开启全部过程,其他Linux发行版可能会有所区别 一、前期准备 使用该命令初始化pacm","tags":null,"title":"Docker打包一个配置好Vim的Arch系统全过程(持续更新)","uri":"https://coder-liuu.github.io/2021/05/docker-arch-nvim-process/","year":"2021"},{"content":".notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Warning\n文章更适合Arch系系统，比如Arch/Manjaro等系统，其他系统可能会有所不同\n Docker基本安装   Pacman 安装 Docker sudo pacman -S docker\n  启动docker服务 sudo systemctl start docker\n  重启docker服务 sudo systemctl restart docker\n  查看docker服务的状态 sudo systemctl status docker\n  设置docker开机启动服务 sudo systemctl enable docker\n  Docker更改镜像源 编辑 /etc/docker/daemon.json,添加如下网易镜像源\n{ \u0026quot;registry-mirrors\u0026quot;: [\u0026quot;http://hub-mirror.c.163.com\u0026quot;] }  Docker简单使用 镜像   搜索镜像列表 docker search nginx\n  下载一个镜像 docker pull 镜像名字\n  使用镜像生成一个容器 docker run -it \u0026lt;镜像名\u0026gt; #-i: 交互式操作, -t: 终端 \u0026ndash;name=容器名字[选加]\n  删除一个镜像\n 方法1  步骤1. 查看镜像,找到镜像ID: docker images 步骤2. 通过镜像ID删除镜像 docker rmi -f \u0026lt;镜像ID\u0026gt; #加上-f强制删除   方法2  docker image rm \u0026lt;镜像名字\u0026gt;      容器   查看运行的容器 docker ps -a\n  停止一个容器 docker stop \u0026lt;容器ID\u0026gt;\n  启动一个容器 docker start \u0026lt;容器ID\u0026gt;\n  进入一个容器\n 方法1.docker attach \u0026lt;容器ID\u0026gt; # 退出后容器自动停止 方法2.docker exec \u0026lt;容器ID\u0026gt; # 退出后容器不停止    删除一个容器\n 步骤1. 查看容器,找到容器ID: docker ps -a 步骤2. 通过容器ID删除容器 docker rmi -f \u0026lt;容器ID\u0026gt; #加上-f强制删除    删除已经停止的容器(核弹命令慎用) docker container prune\n  常用 Tip\n启动一个关闭的容器\n通常我们使用镜像完之后会直接exit退出，但是我们以后想继续进入之前的容器应该怎么进入呢？\n直接使用docker run -it \u0026lt;镜像名\u0026gt;肯定是不行的,因为这样又会生成一个新的容器\n正确做法是通过docker ps -a查看自己以前容器的ID\n然后使用docker start \u0026lt;容器ID\u0026gt; 启动容器\n最终使用docker attatch \u0026lt;容器ID\u0026gt; 进入容器\n Docker和主机之间传输文件   传送之前先运行Docker容器\n  使用docker ps命令查看你想要传输到容器的ID\n  向Docker中传送文件 docker cp 你的文件 容器ID:容器地址，比如docker cp /root/test.txt ecef8319d2c8:/root/\n  Docker向主机传送文件 docker cp 容器ID:容器地址 你的文件，比如docker cp ecef8319d2c8:/root/ /root/test.txt\n  非ROOT用户不用sudo直接执行docker命令  创建名为docker的用户组，如果之间有就会保存，可以忽略这个错误  sudo groupadd docker  将当前用户加入docker组  sudo usermod -aG docker 当前用户的名字  重启docker服务  sudo systemctl restart docker  添加访问和执行权限：  sudo chmod a+rw /var/run/docker.sock  操作完毕，验证一下，现在可以不用带sudo了  Docker保存修改后的镜像 我们运行的容器可能在镜像的基础上很多的修改 们希望保存起来，封装成一个新的镜像。 可以使用docker提供commit功能。\n 把容器打包成镜像 docker commit \u0026lt;容器ID\u0026gt; \u0026lt;新的镜像的名字\u0026gt;  其他参数 -a 提交作者的名字 -m 提交时的说明文字\n查看镜像 docker images  这时候你就会发现，多了一个新的镜像\nDocker登录  登录 docker login  可选参数-u 用户名 -p 密码   登出 docker logout  参考文献 没想到搜来搜去，还是菜鸟教材好啊～\nhttps://www.runoob.com/docker/docker-container-usage.html\n","id":14,"section":"posts","summary":".notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Warning 文章更适合Arch系系统，比如Arch/Manjaro等系统，其他系统可能会有所不同 Docker基本安装 Pacman","tags":null,"title":"Docker使用总结","uri":"https://coder-liuu.github.io/2021/04/docker-used/","year":"2021"},{"content":" Linux的一大痛点，之前修复了一回，不过没有总结，这次总结一下，以便以后在遇到困难好解决。\n 前言 如果是Windows用户很好解决，直接在前面加入下面两行代码即可:\nimport matplotlib.pyplot as plt plt.rcParams['font.sans-serif']=['SimHei']  但是由于Linux缺少字体，上述方法其实是不能解决的\n解决方案 1. 查看字体路径 import matplotlib print(matplotlib.matplotlib_fname())  运行结果如下所示:\n可以看到，我的字体路径为:\n/home/liuyang/.local/lib/python3.7/site-packages/matplotlib/mpl-data/fonts/ttf/\n.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Warning\n注意运行结果路径，不是字体路径,还需要稍加修改，具体如何修改请对比上面的不同\n 2. 下载SimHei字体,点我下载 将下载好的SimHei移动到我的字体路径下。\n3. 删除matplotlib的缓冲目录 通过下面代码进行查看缓冲目录\nimport matplotlib matplotlib.get_cachedir()  然后使用rm命令删除缓存目录\n例如rm -rf xxxxx\n最后字体就可以显示了\n参考链接 https://blog.csdn.net/sinat_40875078/article/details/104326855\n","id":15,"section":"posts","summary":"Linux的一大痛点，之前修复了一回，不过没有总结，这次总结一下，以便以后在遇到困难好解决。 前言 如果是Windows用户很好解决，直接在前面","tags":null,"title":"Linux使用Matplotlib画图中文字体问题","uri":"https://coder-liuu.github.io/2021/04/linux%E4%BD%BF%E7%94%A8matplotlib%E7%94%BB%E5%9B%BE%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/","year":"2021"},{"content":" 强烈吹捧此线代视频:点我出发\n 挑一些重要的写，方便后面复习\n行列式 行列式性质  行列互换，行列式的值不变 对换行列式中两行的位置，行列式变号(推论：行列式两行成比例，则行列式为0。) 某行有公因数k可以将k提出. 行列式某行或某列是两个元素之和，则可以将行列式拆成两个行列式之和 某行的k倍加到另一行，行列式的值不变  行列式展开式  余子式(划去一行一列) 代数余子式(余子式 * $(-1)^{i+j}$) 行列式展开 两个特殊行列式(范德蒙行列式，拉普拉斯行列式) 克拉默法则(求解方程组用的)  行列式求值  2,3阶直接算 上三角行列式计算 行列式展开  矩阵 基本知识  定义 常见矩阵 矩阵运算  矩阵进阶  方阵的行列式(方阵行列式的性质) 伴随矩阵 矩阵的逆(逆矩阵的性质) 分块矩阵运算 对角矩阵  矩阵的初等变换与初等矩阵 基本知识 矩阵初等变换(三种方式) 初等矩阵(性质) 矩阵等价 行阶梯矩阵 行最简矩阵 初等行变换求逆矩阵 秩的概念  ","id":16,"section":"posts","summary":"强烈吹捧此线代视频:点我出发 挑一些重要的写，方便后面复习 行列式 行列式性质 行列互换，行列式的值不变 对换行列式中两行的位置，行列式变号(推论：行","tags":null,"title":"线性代数大纲","uri":"https://coder-liuu.github.io/2021/04/math-linear-algebra/","year":"2021"},{"content":"直接下载(强烈推荐) 我已经传到CSDN上去了，不需要积分，点击出发\n数据集说明如下所示: https://imbalanced-learn.org/stable/datasets/index.html#imbalanced-datasets-for-benchmark\n最简单的使用  安装imblearn库  pip install imblearn  下载你需要的数据集  数据集信息，可以从这里查看(https://imbalanced-learn.org/stable/datasets/index.html)\nfrom imblearn.datasets import fetch_datasets import pandas as pd name = \u0026quot;数据集名字\u0026quot; data = fetch_datasets()['name] data.to_csv(f\u0026quot;{name}.csv\u0026quot;,index=False)  KEEL数据集的使用(不太推荐)  首先去官网: http://www.keel.es/  然后红框中的都是数据集的种类，都是可以下载的\n这里我点击Standard classification data sets (76)这个链接\n如何下载？  如何使用  3.1 如果你用的是matlab应该可以直接使用\n3.2 如果你用的是python,还需要把这个文件转换为.csv文件\n转换文件  转换文件需要KEEL软件,点我去下载,免费\n然后解压文件，进入文件夹，在文件夹中执行下面的命令(需要提前安装java才能运行文件)\njava -jar ./dist/GraphInterKeel.jar  运行软件后，点击这个\n接下来，点击这个\n接下来，点击这个\n接下来，点击这个\n最后点save,然后指定你保存的位置就可以了\n 如果你想将数据集中的文本全部映射成数字，可以执行下面的python代码,（记得替换数据集的名字）\n import pandas as pd name = \u0026quot;数据集名字（不需要后缀）\u0026quot; data = pd.read_csv(f\u0026quot;{name}.csv\u0026quot;) columns = data.columns data = data.rename(columns={columns[-1]:\u0026quot;class\u0026quot;}) columns = data.columns def dic(a,b): print(a) data_dict = {} for id_,i in enumerate(a): data_dict[i] = b[id_] return data_dict for col in columns: a = data[col].unique() if type(a[0]) == str: b = list(range(1,len(a)+1)) data_dict = dic(a,b) data[col] = data[col].map(data_dict) data.to_csv(f\u0026quot;{name}-2.csv\u0026quot;,index=False)  ","id":17,"section":"posts","summary":"直接下载(强烈推荐) 我已经传到CSDN上去了，不需要积分，点击出发 数据集说明如下所示: https://imbalanced-learn.org/stable/datasets/index.html#imbalanced-datasets-for-benchmark 最简单的使用 安装imblearn库 pip install imblearn 下载你需要的","tags":null,"title":"不平衡数据集","uri":"https://coder-liuu.github.io/2021/03/imbalanced-datasets/","year":"2021"},{"content":" 逻辑回归完整代码想抄作业的同学直接点这里\n 一、逻辑回归算法简介 逻辑回归又称对数几率回归\n在线性回归模型中，我们学会了使用线性模型完成回归的问题，但是如果任务是分类任务怎么办呢?答案是使用一个单调可微函数将实际标签y和线性回归的预测值联系起来\n首先考虑二分类任务，实际标签为0或1，而线性回归模型的预测值为$z = XW + b$为实值，于是我们使用单位阶跃函数，将z转换为0/1值。\n阶跃函数如下所示:\n\\[ y = \\begin{cases} 0, z 0 \\\\ \\end{cases} \\]\n但是，我们可以发现阶跃函数有一些硬直，不可求导，因此使用更加平滑的Sigmoid function代替。\nSigmoid函数如下所示:\n\\[ prob = \\frac{1}{1 + e^{-z}} \\]\n如果Sigmoid函数输出的prob值，我们可以进一步确定样本的类别，比如prob\u0026gt;0.5，样本类别为1,prob\u0026lt;=0.5样本类别为0\n阶跃函数如下图中的红线所示，而Sigmoid如下图中的黑线所示：\n\n二、怎么求解 逻辑回归计算过程很简单就是：将数据带入z = XW + b中，然后将z带入Sigmoid函数中去，最终求得计算结果。\n 但是我们怎么求解W的值呢?\n 损失函数 损失函数的定义： 通过Sigmoid我们可以计算出所属类别的概率，因此我们可以更好的定义损失函数。\n逻辑回归中的损失函数如下所示，下面我们进行讨论合理性\n\\[ loss = - y^* log(prob) - (1 - y^*)log(1 - prob) \\]\n其中\\(y^*\\)为标签的实际值，prob是Sigmoid函数的输出值。\n这个函数很有意思\n当\\(y^*=1\\)时，\\(loss=-log(prob)\\)，意思就是prob值越接近1越好。\n当\\(y^*=0\\)时，\\(loss=- log(1 - prob)\\)，意思就是prob值越接近0越好。\n总之，该损失函数能使prob值和数据的标签尽可能接近。\n求解最优权重-求梯度 为了更好理解梯度的求法，我们重新写一下数据进行计算的过程\n\\[z = w_0 + w_1 x_1 + w_2 x_2 = \\ \\left[ \\begin{matrix} 1 \u0026 x_1 \u0026 x_2 \\end{matrix} \\right] \\ \\left[ \\begin{matrix} w_0 \\\\ w_1 \\\\ w_2 \\end{matrix} \\right] \\tag{1} \\]\n\\(Z = XW \\tag{2}\\),其中假设有10组数据每条数据有3个属性1个标签X维度(10,3),Z维度(10,1)\n 计算Z对W的导数，为下文做铺垫\n\\[\\frac{d Z}{d W} = X^T \\]\n \\( prob = \\frac{1}{1 + e^{-z}} \\tag{3}\\) prob维度为(10,1)\n 计算prob对z的导数，为下文做铺垫\n\\[\\frac{d prob}{d z} = \\frac{e^{-z}} { (1+e^{-z})^2 } = \\frac{1}{1 + e^{-z}} \\frac{e^{-z}}{1 + e^{-z}} = prob (1 - prob) \\]\n 综合公式1-3,可得 \\( prob = \\frac{1}{1 + e^{-XW}} \\)\n\\[ loss = -y^*log(prob) -(1-y)*log(1-prob) \\tag{4}\\]\n 计算loss对prob的导数，为下文做铺垫\n\\[\\frac{d loss}{d prob} = - \\frac{y^*}{prob} - \\frac{1 - y^*}{1-prob} * -1 \\]\n 接下来进行链式求导，其中loss ~ prob ~ z ~ WX\n注意下面的计算都是元素级元素，不涉及到矩阵运算\n\\[ grad = \\frac{d loss}{d W} = \\frac{d loss}{d prob} * \\frac{d prob}{d z} * \\frac{d z}{W} \\\\ = X^T (- \\frac{y^*}{prob} + \\frac{1 - y^*}{1-prob}) * prob(1 - prob) \\\\ = X^T ( - y^*(1 - prob) + (1 - y^*)prob ) \\\\ = X^T (prob - y^*) \\]\n最终结果维度为(3,10)乘以(10,1)等于(3,1)\n求解最优权重-梯度下降 步骤1. 初始化W\n步骤2. W -= lr * grad (其中lr为学习率，值到0-1之间)\n步骤3. 迭代都一定次数，或阈值停止\n.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Warning\n纸上得来终决浅，写一边代码便能收获颇多，这里建议你点击我，查看源代码，进行仿写\n 四、代办事项  可视化梯度下降的整个过程  参考博客 https://www.bilibili.com/video/BV1As411j7zw?from=search\u0026amp;seid=13110094973136261265\n","id":18,"section":"posts","summary":"逻辑回归完整代码想抄作业的同学直接点这里 一、逻辑回归算法简介 逻辑回归又称对数几率回归 在线性回归模型中，我们学会了使用线性模型完成回归的问题，","tags":null,"title":"动手机器学习-实现逻辑回归","uri":"https://coder-liuu.github.io/2021/03/ml-logisticregression/","year":"2021"},{"content":" 线性回归完整代码想抄作业的同学直接点这里\n  岭回归完整代码想抄作业的同学直接点这里\n 一、线性回归算法简介 线性回归是经典的回归算法\n线性回归是通过属性的线性回归来进行预测的函数，一个具有n个特征的数据集的线性回归方程如下所示:\n$$ f(x) = w_1 x_1 + w_2 x_2 + \u0026hellip; + w_n x_n; $$\n用向量表示为\n$$ f(x) = w^T x + b $$\n由于线性回归的w可以很直观的表示出来，假如“在西瓜数据中”学到的方程为$f_好瓜(x) = 0.2 x_{色泽} + 0.5 x_{根蒂} + 0.3 x_{敲声} + 1$，我们可以通过这个方程发现根蒂在判断西瓜好坏起着很重要的作用。\n线性回归算法，主要有两部分：\n 参数的求解(核心) 参数的惩罚  二、参数的求解(最小二乘法) 考虑最简单只有一个属性时，这个属性如果是离散属性，那么应该要转换为连续属性。有序属性，例如身高的高矮，可以转换为{1.0, 0.0}。而三个无序数据例如西瓜，南瓜，黄瓜可以转化为(1,0,0),(0,1,0),(0,0,1)\n确定w和b是最关键的,我们采用均方误差来衡量算法的性能，所以我们的目的就是让线性回归模型的均方误差最小化，数学公式表达为:\n$$ (w^* , b^*) = argmin \\sum_{i=1}^{m} ( f(x_i) - y_i )^2 $$\n怎么求解参数使得均方误差最小呢？使用最小二乘法，可以直接求解出来。理论公式推倒略，最终公式如下所示：\n$$ w^* = (X^T X)^{-1} X^T y $$\n其中$X = (1,x)$,简单来说为在x矩阵前加上一列1,为X。满足能计算出w的前提是$X^T X$存在逆矩阵。\n三、参数的惩罚 L2惩罚: 改变原始的目标函数为:\n$$ (w^* , b^*) = argmin \\sum_{i=1}^{m} ( (f(x_i) - y_i )^2 + a \\sum w^2 ) $$\n公式中的$a\\sum w^2$ 成为L2惩罚项\n使用L2惩罚的原因为：为了更好的拟合训练数据中，x的很小变化而y却变大许多，所以必须使用更大的w。最终会导致过度拟合的现象，所以在目标函数中加入$w^2$，来避免出现很大的w，最终减小模型的过拟合。\n其中$a$是一个可变参数，其中$a$越大惩罚越严重，模型越平缓。\n引入L2的线性回归又称作：岭回归\nL1惩罚: 改变原始的目标函数为:\n$$ (w^* , b^*) = argmin \\sum_{i=1}^{m} ( (f(x_i) - y_i )^2 + a \\sum |w| ) $$\n公式中的$a\\sum |w|$ 成为L2惩罚项\n使用L1惩罚的原因为：虽然L2惩罚可以解决回归参数过大的问题，但是很难达到零值，这样的后果为：虽然有很多特征对最终结果影响很小，但是还是要加入模型的计算中去，而L1惩罚比L2惩罚严厉很多，可以使模型许多回归参数变为零，最终达到压缩相关特征的目的\n其中$a$是一个可变参数，其中$a$越大惩罚越严重，模型越平缓。\n引入L1的线性回归又称作：Lasso回归\n四、探索性问题 这即是探索性的问题，也是我自己的代办问题解答，如果有时间，我一定会完善下面的问题。\n 线性回归和对数线性回归的关系  对数线性回归的公式如下： $$ lny = w^T x + b $$ 它实际上是在试图让$e^{w^T x + b}$去逼近$y$。形式上仍是线性回归，但实质上在求取输入空间到输出空间的非线性函数映射，更一般地，考虑单调可微函数$g(x)$，令\n$$ y = g^{-1} (w ^ T x + b) $$ 这样的模型称作广义线性模型，其中函数$g(x)$被成为联系函数。显然当联系函数$g(x) = ln(x)$时，便是对数线性回归。\n线性回归对数据集有什么要求呢?  ","id":19,"section":"posts","summary":"线性回归完整代码想抄作业的同学直接点这里 岭回归完整代码想抄作业的同学直接点这里 一、线性回归算法简介 线性回归是经典的回归算法 线性回归是通过属性","tags":null,"title":"动手机器学习-实现线性回归","uri":"https://coder-liuu.github.io/2021/03/ml-linearregression/","year":"2021"},{"content":" KMeans完整代码想抄作业的同学直接点这里\n 一、KMeans算法简介 KMeans是经典的聚类算法\n假设要在一个新的城市中，开几个大型商场，应该怎样选址才能吸引更多客户呢？如果显然都商场都建立在郊区不是最好的选择，但是商场都建立市中心也不是最好的选择。其中一种解决方案就使所有居民距离自己区域的商场距离最近。\nKMeans算法，主要由两部分组成：\n 初始聚类中心的选择 聚类中心的迭代更新  二、初始聚类中心的选择 随机选择 随机选择是最简单的一种初始化聚类中心的方法，其步骤就是随机从数据中选取K个样本，作为初始的聚类中心。\nk-means++ k-means++的步骤是：先随机选取一个点，然后在选择下一个点时，选择与已选择点距离最远的样本点。可以说\u0026quot;k-means++\u0026ldquo;是一种倾向于选择相互距离较远的样本点最为初始点(这个初始化的方法目前，没有在代码中实现)\n三、聚类中心的迭代更新 Kmeans算法的目标为: 找到合适的聚类中心，使得所有样本到其分组中心的距离的平方最小，用数学公式表达，假设有N个样本，K个聚类中心，Kmeans的目标为:\n$$ E = \\sum_{i=1}^{k} \\sum_{x \\in C_i } distant(x - \\mu_i) ^ 2 $$\n其中，$ \\mu_i = \\frac{1}{C_i} \\sum{}{x \\in C_i } $，$\\mu_i$是簇$C_i$的均值向量。\n如果直接求最合适的聚类中心，很难，这是一个NP难问题，因此K-means算法采用贪心策略通过迭代来求近似最优解。\n算法流程如下所示:\n我们可以将书中的伪代码，进一步抽象可以分为下面几个步骤\n 计算每个样本与每个聚类中心的距离 将样本划分到距离样本最近的聚类簇当中去 重新计算聚类中心点向量 如果新聚类中心点向量 跟 旧的聚类中心点向量不一样，更新聚类中心点向量 如果一样或者达到最大迭代次数，算法完毕  举个例子\n西瓜数据集如下所示，手动模拟Kmeans算法，将数据集聚类成2类.\n   样本编号 密度 重量     1 1 3   2 1 4   3 3 5   4 5 5    步骤0: 随机选择两个样本作为聚类中心点\n假设选择样本编号为1,2的样本最为初始聚类中心点\n$\\mu_1 = {1,3} $ $\\mu_2 = {1,4} $\nCenter = {{1,3},{1,4}}\n步骤1: 计算每个样本到聚类中心点的距离\n   欧式距离平方 $\\mu_1$ $ \\mu_2$     样本1 0 1   样本2 1 0   样本3 4+4=8 4+1=5   样本4 16+4=20 16+1=17    步骤2: 将样本划分到距离样本最近的聚类簇当中去\n聚类簇1的样本为 {样本1}\n聚类簇2的样本为 {样本2,样本3,样本4}\n步骤3: 重新计算聚类中心点向量\n$\\mu_1 = {1,3} $ $\\mu_2 = {3,4.66} $\n步骤4: 判断新聚类中心是否和旧聚类中心一样\n答案不一样，继续执行步骤1\n第二轮,步骤1: 计算每个样本到聚类中心点的距离\n.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Warning\n注意这里$ \\mu $ 已经更新了\n    欧式距离平方 $\\mu_1$ $ \\mu_2$     样本1 0 4+2.56=6.56   样本2 1 4+0.36=4.36   样本3 4+4=8 0+0.09=0.09   样本4 16+4=20 4+0.09=4.99    第二轮，步骤2: 将样本划分到距离样本最近的聚类簇当中去\n聚类簇1的样本为 {样本1,样本2}\n聚类簇2的样本为 {样本3,样本4}\n第二轮，步骤3: 重新计算聚类中心点向量\n$\\mu_1 = {1,3.5} $\n$\\mu_2 = {4,5} $\n第二轮，步骤4: 判断新聚类中心是否和旧聚类中心一样\n答案不一样，继续执行步骤1\n第三轮,步骤1: 计算每个样本到聚类中心点的距离\nWarning\n注意这里$ \\mu $ 又更新了\n    欧式距离平方 $\\mu_1$ $ \\mu_2 $     样本1 0.25 9+4=13   样本2 0.25 9+1=10   样本3 4+2.25=6.25 1+0=1   样本4 16+2.25=18.25 1+0=1    第三轮，步骤2: 将样本划分到距离样本最近的聚类簇当中去\n聚类簇1的样本为 {样本1,样本2}\n聚类簇2的样本为 {样本3,样本4}\n第二轮，步骤3: 重新计算聚类中心点向量\n$\\mu_1 = {1,3.5} $\n$\\mu_2 = {4,5} $\n第三轮，步骤3: 重新计算聚类中心点向量\n$\\mu_1 = {1,3.5} $\n$\\mu_2 = {4,5} $\n第三轮，步骤4: 判断新聚类中心是否和旧聚类中心一样\n答案一样，迭代结束\n结果: 聚类中心点为\n$C_1 = {1,3.5}$\n$C_2 = {4,5}$\n算法结束\n四、探索性问题 这即是探索性的问题，也是我自己的代办问题解答，如果有时间，我一定会完善下面的问题。\n  Kmeans怎么对数据集属性进行加权?\n  Kmeans三种初始化聚类中心的详细过程?\n  ","id":20,"section":"posts","summary":"KMeans完整代码想抄作业的同学直接点这里 一、KMeans算法简介 KMeans是经典的聚类算法 假设要在一个新的城市中，开几个大型商场，应该","tags":null,"title":"动手机器学习-\u003e实现KMeans算法","uri":"https://coder-liuu.github.io/2021/03/ml-kmeans/","year":"2021"},{"content":"正文  Linux也可以制作U盘启动盘,而且不需要使用其他外部工具,非常简单\n  使用命令sudo fdisk -l,找到自己U盘  执行结果中一般最后一个Disk是自己的U盘,当然也需要自己额外注意一下磁盘大小和U盘大小是否相匹配,防止后面出现问题.\n使用sudo umont /dev/sdb,卸载自己的U盘 使用sudo mkfs.vfat /dev/sdb -I,格式化自己的U盘 制作启动盘  命令如下所示:\nsudo dd if=~/Downloads/ubuntu-16.04-desktop-amd64.iso of=/dev/sdb status=progress  参考文章 李空空\n","id":21,"section":"posts","summary":"正文 Linux也可以制作U盘启动盘,而且不需要使用其他外部工具,非常简单 使用命令sudo fdisk -l,找到自己U盘 执行结果中一般最后一个Disk是","tags":null,"title":"Linux下使用dd命令制作启动盘","uri":"https://coder-liuu.github.io/2021/03/linux-dd/","year":"2021"},{"content":" 决策树完整代码想抄作业的同学直接点这里\n 一、决策树简介 决策树是一个很简单的机器学习算法,可以看作if-then的集合,比如我们判断一个西瓜的好坏?我们很可能通过一系列的问题进行判断,比如首先我们问西瓜是绿色的吗?如果是接下来问西瓜甜不甜呢？这就是一颗决策树.\n决策树算法,主要由两部分组成:\n 划分选择 决策树的生成  下面，将从这两方面进行介绍，并提供对应的python代码，以及手写一颗决策树.\n二、划分选择 我们首先要想西瓜的哪个特征对结果影响最大呢?也就是说，先问最关键的问题. 这时候需要引入一个概念信息增益\n在介绍信息增益前，先要了解信息熵是什么?\n信息熵(entropy): 是度量样本集合纯度的一种最常用的指标，简单说就是这是事件的不确定性的大小，熵越大事件就越不确定，熵为0时，说明这是一个确定性事件。\n计算方法: $$ D = [P_1,P_2,\u0026hellip;,P_n] $$ $$ Ent(D) = -\\sum_{i=1}^n P_i log_2P_i $$\n计算示例1: 有一个不均匀硬币,其中正面向上的概率为$\\frac{1}{3}$,反面向上的概率也是$\\frac{2}{3}$,则该事件的熵的计算公式如下:\n$$ Ent(D) = - ( \\frac{1}{3} log_2\\frac{1}{3} + \\frac{2}{3} log_2\\frac{2}{3} ) = 0.918$$\n计算示例2: 有一个均匀硬币,其中正面向上的概率为$\\frac{1}{2}$,反面向上的概率也是$\\frac{1}{2}$,则该事件的熵的计算公式如下:\n$$ Ent(D) = - ( \\frac{1}{2} log_2\\frac{1}{2} + \\frac{1}{2} log_2\\frac{1}{2} ) = 1 $$\n可以看到均匀硬币,有更大的信息熵,所以均匀硬币不确定的结果也就越大。\n接下来就可以说一下信息增益了，信息增益就是得知信息A而使事件D不确定性，减小的程度，用公式表示为$ g(D,X) = Ent(D) - Ent(D|A) $.\n举个例子：假如刚开始有一枚硬币，我们认为硬币是均匀的，所以信息熵为1,但是经过测量我们发现硬币是不均匀的，不均匀程度如上面的计算示例1所示,所以现在的信息熵为0.918.最终我们知道了这个信息的信息增益为$1-0.918=0.082$\n计算信息熵的代码如下所示:\nimport numpy as np def entropy(y): # y是事件的结果，比如抛硬币1次正，2次反.y就为[1,2,2] hist = np.bincount(y) ps = hist / np.sum(hist) return -np.sum([p * np.log2(p) for p in ps if p \u0026gt; 0])  三、决策树的生成 决策树的种类有多种多样，先放一个通用的决策树的为代码,其中红色标注的我们已经学会了\n我们可以将书中的伪代码，进一步抽象可以分为下面几个步骤\n 如果数据集中样本为同一类别或者没有特征可以继续划分，停止划分为叶结点赋值 选择最优划分属性 以最优属性将原数据集分为两个数据集，递归构建决策树  接下来我们说一下决策树中经典算法ID3算法，其实不同的决策树主要的区别就在于第2步,ID3算法使用信息增益来作为评价最优属性的标准。\n举个例子\n数据集如下所示，使用ID3算法构建决策树.\n   编号 敲声 颜色 好瓜     1 响 绿色 是   2 不响 绿色 是   3 响 黄色 不是    步骤1: 查看数据集是否都是同一类别,答案不是\n步骤2: 寻找最优划分属性 初始信息熵为: $$ Ent = -(\\frac{2}{3} log_2 \\frac{2}{3} + \\frac{1}{3} log_2 \\frac{1}{3}) = 0.918 $$\n假设以敲声划分，敲声响中(1好瓜,1坏瓜),敲声不响中(1好瓜,0坏瓜)，计算公式如下所示:\n$$ Ent(敲声) = - \\frac{2}{3} (\\frac{1}{2} log_2 \\frac{1}{2} + \\frac{1}{2} log_2 \\frac{1}{2}) - \\frac{1}{3} (\\frac{1}{1} log_2 \\frac{1}{1} + \\frac{0}{1} log_2 \\frac{0}{1}) = 0.666 + 0 = 0.666 $$\n.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Warning\n在计算的过程中，规定$\\frac{0}{1} log_2 \\frac{0}{1} = 0$\n 假设以颜色划分，绿色中(2好瓜,0坏瓜),黄色中(0好瓜,1坏瓜)，计算公式如下所示:\n$$ Ent(颜色) = - \\frac{2}{3} (\\frac{2}{2} log_2 \\frac{2}{2} + \\frac{0}{2} log_2 \\frac{0}{2}) - \\frac{1}{3} (\\frac{0}{1} log_2 \\frac{0}{1} + \\frac{1}{1} log_2 \\frac{1}{1}) = 0 + 0 = 0$$\n敲声的信息增益为: $ 0.918 - 0.666 = 0.252 $\n颜色的信息增益为: $ 0.918 - 0 = 0.918 $\n所以颜色为决策树的根节点，接下来我们考虑该节点的儿子节点.\n步骤3: 划分数据集\n使用颜色划分数据集，划分规则是相同颜色的数据为一个数据集。\n即下标为1,2的是数据集S1,下标为3的是数据集S2\n步骤4: 查看数据集S1,S2是否都是同一类别,答案是,所以停止划分,我们发现数据集S1全部为好瓜所以该节点为绿色,而另一个节点为坏瓜,最终决策树如下图所示:\n四、探索性问题 这即是探索性的问题，也是我自己的代办问题解答，如果有时间，我一定会完善下面的问题。\n  决策树怎么处理连续值？\n  决策树怎么进行剪枝?\n  ","id":22,"section":"posts","summary":"决策树完整代码想抄作业的同学直接点这里 一、决策树简介 决策树是一个很简单的机器学习算法,可以看作if-then的集合,比如我们判断一个西瓜的好","tags":null,"title":"动手机器学习-\u003e实现决策树","uri":"https://coder-liuu.github.io/2021/02/ml-decision-tree/","year":"2021"},{"content":"快速排序 时间复杂度: $O(nlog(n))$,模板题\nvoid quick_sort(int q[],int l,int r){ if(l \u0026gt;= r) return; // 1. 寻找分界点 int x = q[(l + r)/2],i = l - 1, j = r + 1; // 2. 调整区间 while(i \u0026lt; j){ do i++; while(q[i] \u0026lt; x); do j--; while(q[j] \u0026gt; x); if(i \u0026lt; j) swap(q[i],q[j]); } // 3. 分布递归 quick_sort(q,l,j); quick_sort(q,j+1,r); }  归并排序 时间复杂度: $O(nlog(n))$,模板题\nvoid merge_sort(int q[],int l,int r){ if(l \u0026gt;= r) return; // 1. 确定分界点 int mid = (l + r) \u0026gt;\u0026gt; 1; // 2. 进行递归 merge_sort(q,l,mid); merge_sort(q,mid+1,r); // 3. 合并区间 int k = 0, i = l, j = mid + 1; while(i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if(q[i] \u0026lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while(i \u0026lt;= mid) tmp[k++] = q[i++]; while(j \u0026lt;= r) tmp[k++] = q[j++]; for(i = l, j = 0; i \u0026lt;= r; i++, j++) q[i] = tmp[j]; }  二分查找 bool check(int x); // 检查x是否满足某种性质 // 最小满足点: 若mid满足搜索[l,mid],否则搜索[mid+1,r] // 一段区间，开始不满足后来满足 int bsearch_low(int l,int r){ while(l \u0026lt; r){ int mid = l + r \u0026gt;\u0026gt; 1; if( check(mid) ) r = mid; else l = mid + 1; } } // 最大满足点: 若mid满足搜索[mid,r],否则搜索[l,mid-1] // 一段区间，开始满足后来不满足 int bsearch_high(int l,int r){ while(l \u0026lt; r){ int mid = l + r + 1 \u0026gt;\u0026gt; 1; if( check(mid) ) l = mid; else r = mid - 1; } }  高精度加法模板 需要注意的是： A是一个从低位到高位的数组，比如A是[1,2,3],代表的值是321\nvector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A,vector\u0026lt;int\u0026gt; \u0026amp;B){ vector\u0026lt;int\u0026gt; C; int t = 0; for(int i = 0; i \u0026lt; A.size() || i \u0026lt; B.size(); i++){ if(i \u0026lt; A.size()) t += A[i] - '0'; if(i \u0026lt; B.size()) t += B[i] - '0'; C.push_back(t % 10); t /= 10; } if(t) C.push_back(1); return C; }  高精度减法模板 vector\u0026lt;int\u0026gt; sub(v \u0026amp; A, v \u0026amp; B){ for(int i = 0; i \u0026lt; A.size() ; i++){ A[i] -= B[i]; if(A[i] \u0026lt; 0){ A[i] += 10; A[i+1] -= 1; } } // 去掉前导0 while(A.size() \u0026gt; 1 \u0026amp;\u0026amp; A.back() == 0) A.pop_back(); return A; }  字符串杂知识 // C++ string 转 C string s1.c_str(); // 字符串取字串 // 在字符串s1上从start位置开始截取，截取length长度 s1.substr(start,length); // 查找字符串某个字符的位置 s1.find('x')  C++ 切割字符串 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;sstream\u0026gt; using namespace std; vector\u0026lt;string\u0026gt; v1; int main(){ string tmp_s = \u0026quot;123\u0026amp;1234\u0026amp;90\u0026quot;; stringstream ss(tmp_s); while (getline(ss, tmp_s, '\u0026amp;')) { v1.push_back(tmp_s); } return 0; }  清空queue void clear(queue\u0026lt;string\u0026gt; \u0026amp; q){ queue\u0026lt;string\u0026gt; empty; swap(empty,q); }  ","id":23,"section":"posts","summary":"快速排序 时间复杂度: $O(nlog(n))$,模板题 void quick_sort(int q[],int l,int r){ if(l \u0026gt;= r) return; // 1. 寻找分界点 int x = q[(l + r)/2],i = l - 1, j = r + 1; // 2. 调整区间 while(i \u0026lt; j){ do i++; while(q[i] \u0026lt;","tags":null,"title":"ACM基础算法模板","uri":"https://coder-liuu.github.io/2021/02/acm-base/","year":"2021"},{"content":"朴素的Dijkstra算法 求点之间距离不相同的最短路算法\n时间复杂度$O(n^2+m)$,n表示点数,m表示边数,模板题\nint g[N][N]; // 存储图 int dist[N]; // 1号点到每个点的距离 int st[N]; // 是否已经确定为最小距离 int n,m; // 点数 边数 int dijkstra(){ // 初始化距离 memset(dist,0x3f,sizeof(dist)); dist[1] = 0; for(int i = 0; i \u0026lt; n - 1; i++){ // 找到没有在集合st中，距离起点最近的点 int t = -1; for(int j = 1; j \u0026lt;= n; j++) if(!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; // 更新距离 for(int j = 1; j \u0026lt;= n; j++) dist[j] = min(dist[j],dist[t] + g[t][j]); // 将该点加入st中 st[t] = true; } return dist[n] == 0x3f3f3f3f ? -1 : dist[n]; }  堆优化的Dijkstra算法 typedef pair\u0026lt;int,int\u0026gt; PII; priority_queue\u0026lt; PII,vector\u0026lt;PII\u0026gt;,greater\u0026lt;PII\u0026gt; \u0026gt; heap; const int N = 1e5 + 10; vector\u0026lt;PII\u0026gt; g[N]; int dist[N]; // 1号点到每个点的距离 int st[N]; // 是否已经确定为最小距离 int n,m; // 点数 边数 int dijkstra(){ // 初始化距离 memset(dist,0x3f,sizeof(dist)); dist[1] = 0; heap.push({0, 1}); for(int i = 1; i \u0026lt; n; i++){ // 找到没有在集合st中，距离起点最近的点 auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; // 将该点加入st中 if(st[ver]) continue; st[ver] = true; // 更新距离 for(auto to : g[ver]){ int dis = to.first, tar = to.second; if(dist[tar] \u0026gt; dist[ver] + dis){ dist[tar] = dist[ver] + dis; heap.push({dist[tar],tar}); } } } return dist[n] == 0x3f3f3f3f ? -1 : dist[n]; } int main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; while(m--){ int a,b,c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; // g[a][b] = min(g[a][b],c); // 先是距离，后是点 g[a].push_back({c,b}); } cout \u0026lt;\u0026lt; dijkstra(); return 0; }  拓扑排序 DAG: 有向无环图\n拓扑序形象理解: 一些敌人可以互相看到，你要暗杀所有人而不被发现\n模板题链接: https://acwing.com/problem/content/description/850/\n伪代码:\n把所有入度为零的点，扔到一个队列里: while 队列非空: 取队首点P 访问P的所有相邻点O，将其入度减一 若此时入度为0,Q入队  #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int N = 1e5+10; int deg[N]; vector\u0026lt;int\u0026gt; v[N]; queue\u0026lt;int\u0026gt; q; int n,m; vector\u0026lt;int\u0026gt; topsort(){ vector\u0026lt;int\u0026gt; ans; for(int i = 1; i \u0026lt;= n; i++) if(deg[i] == 0) q.push(i); while(q.size()){ int now = q.front(); ans.push_back(now); q.pop(); for(auto to: v[now]){ deg[to] -= 1; if(deg[to] == 0) q.push(to); } } return ans; } int main(){ ios::sync_with_stdio(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; while(m--){ int x,y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; v[x].push_back(y); deg[y]++; } auto res = topsort(); if(res.size() == n) for(auto x: res) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026quot; \u0026quot;; else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; }  SPFA算法 求图中的带有负边的最短路算法\nn表示点数,m表示边数 最好时间复杂度$O(m)$,最好时间复杂度$O(nm)$,模板题\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 1e5 + 10; int n,m; typedef pair\u0026lt;int,int\u0026gt; PII; vector\u0026lt;PII\u0026gt; g[N]; int st[N]; int dist[N]; int spfa(){ memset(dist,0x3f,sizeof dist); queue\u0026lt;int\u0026gt; q; q.push(1); st[1] = true; dist[1] = 0; while(q.size()){ int front = q.front(); q.pop(); st[front] = false; for(auto to : g[front]){ int t = to.first; int w = to.second; if(dist[t] \u0026gt; dist[front] + w){ dist[t] = dist[front] + w; if( !st[t] ) { st[t] = true; q.push(t); } } } } if(dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } int main(){ ios::sync_with_stdio(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; while(m--){ int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; g[u].push_back({v,w}); } int res = spfa(); if(res == -1) cout \u0026lt;\u0026lt; \u0026quot;impossible\u0026quot; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; }  朴素的Prim算法 求图中的最小生成树算法\n时间复杂度$O(n^2+m)$,n表示点数,m表示边数,模板题\nconst int N = 550, INF = 0x3f3f3f3f; int g[N][N], st[N], dist[N]; int n,m; int prim(){ // 初始化到集合的距离 memset(dist,0x3f,sizeof dist); int res = 0; for(int i = 0; i \u0026lt; n; i++){ // 寻找到集合最近的点 int t = -1; for(int j = 1; j \u0026lt;= n; j++) if(!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; // 如果不是第一个点，并且距离为正无穷 // 返回正无穷，也就是没有最小生成树 if(i \u0026amp;\u0026amp; dist[t] == INF) return INF; // 距离相加 if(i) res += dist[t]; st[t] = true; // 更新距离 for(int j = 1; j \u0026lt;= n; j++) dist[j] = min(dist[j],g[t][j]); } return res; }  tarjan算法 求图中的强联通分量\nint dfn[N], low[N]; // 高低数组 int stk[N], top, ts; // 模拟栈 bool in_stk[N]; // 是否在栈中 void tarjan(int now){ // 0. 准备遍历now这个点 dfn[now] = low[now] = ++ ts; stk[++top] = now, in_stk[now] = true; for(int to:v[now]){ // 1. 看看下一个点是否能更新当前点的时间戳 if(!dfn[to]){ tarjan(to); low[now] = min(low[now],low[to]); } // 2. 下一个点在栈中，看看能否更新当前点的时间戳 else if(in_stk[to]) low[now] = min(low[now],low[to]); } // 3. 将当前节点进行出栈 if(dfn[now] == low[now]){ int y,cnt = 0; do{ y = stk[top --]; in_stk[y] = false; }while(y != now); } }  ","id":24,"section":"posts","summary":"朴素的Dijkstra算法 求点之间距离不相同的最短路算法 时间复杂度$O(n^2+m)$,n表示点数,m表示边数,模板题 int g[N][N]; // 存储图 int dist[N]; // 1号","tags":null,"title":"图论知识总结","uri":"https://coder-liuu.github.io/2021/02/acm-argph-theory/","year":"2021"},{"content":" Manjaro怎么更新DNS呢?默认终端怎么改?怎么在终端下播放音乐?等等一系列问题\n 更新DNS缓存 查看DNS网址,网址\n修改Hosts文件: vim /etc/hosts\n刷新dns: sudo systemctl restart NetworkManager.service\n各种系统更新DNS缓存的方法-\u0026gt;点我出发\nArch有网络,浏览器无法访问 重启网络: systemctl restart systemctl-networkd\nManjaro-gnome设置默认终端 将alaritty设置为我的默认终端,命令: gsettings set org.gnome.desktop.default-applications.terminal exec alaritty\n终端下播放音乐 介绍:SOX软件,支持很多格式的音频文件,如 WAV,MP3,MPG,OGG,FLAC 等等.\nArch安装: sudo pacman -S sox\n使用方法: play xxx.mp3\nLinux符号连接的层数过多 ln软链接用法: ln -s 源文件 目标文件\n但是有时候我们软链接文件夹，会提示我们Linux符号连接的层数过多\n解决办法:将相对路径替换成绝对路径\n","id":25,"section":"posts","summary":"Manjaro怎么更新DNS呢?默认终端怎么改?怎么在终端下播放音乐?等等一系列问题 更新DNS缓存 查看DNS网址,网址 修改Hosts文件: vim","tags":null,"title":"Manjaro-DNS等问题.md","uri":"https://coder-liuu.github.io/2021/02/manjaro-some-problem/","year":"2021"},{"content":" ranger是一款终端下的文件管理器,具有Vim式的操作方式.\n 我曾无数次安装ranger,也曾无数次配置ranger.\n1.安装 Ranger官网上有更加丰富的介绍,本文针对少数常用功能进行介绍.\n  Arch/Manjaro安装: sudo pacman -S ranger\n  Ubuntu安装: sudo apt install ranger\n  Pip安装: pip install ranger-fm\n  当然你也可以下载源代码进行手动安装\n  最终在终端下输入ranger即可打开程序了\n2.使用 使用h,j,k,l来进行光标的移动,来穿越在不同的文件夹中\n使用q进行退出程序,使用S来进行当前光标所在的文件夹中(进入文件夹后终端下执行exit命令重新回到ranger程序当中去)\n3.配置 我相当推荐你去配置自己的ranger,因为这样ranger会对你更加的友好、舒服.\n使用ranger --copy-config=all将在~/.config/ranger中生成一系列配置文件,其中ranger主要有4个配置文件.\n rc.conf 常用于设置选项和绑定快捷键.(最常用) scope.sh 常用于设置文件的预览方式. rifle.conf 常用于设置使用那个软件来打开文件. commands.py python文件,增强和改进ranger的各种功能.  我们最常用的就是绑定快捷键了,下面我们说一说怎么在rc.conf文件中自定义我们的快捷键. 一般来说,我习惯将我自己定义的快捷键放到文件的末尾.我们以自定义创建文件夹快捷键为例.\n在文件的最后写入:map mk console shell mkdir%space\nmap: 是一个映射的关键字\nmk: 我们自定义的快捷键为mk\nconsole shell: 告诉系统我们接下来打算映射shell指令\nmkdir%space: 映射的shell命令为mkdir,其中%space为一个空格而已\nFAQ Ranger图片预览问题解决 如果觉得自己的配置文件已经被更改的乱七八糟了,请使用ranger --copy-config=all回到最初的起点.\n安装ueberzug软件作为图片预览的程序.使用Manjaro命令如下sudo pacman -S neberzug,接下来修改ranger的rc.confg配置文件,主要改动的几行改动完如下所示:\nset preview_images true set preview_images_method ueberzug set draw_borders true  最终重新启动,大工告成!\nRanger视频预览图功能  安装ffmpegthumbnailer用来生成视频预览图,Manjaro安装方式为:sudo pacman -S ffmpegthumbnailer 在scope.sh中，注释掉ffmpegthumbnailer这一块代码的内容 安装mplayer,可以更好的观看视频,我安装还是使用pacman啦~  相关资料 https://zhuanlan.zhihu.com/p/105731111\n","id":26,"section":"posts","summary":"ranger是一款终端下的文件管理器,具有Vim式的操作方式. 我曾无数次安装ranger,也曾无数次配置ranger. 1.安装 Ranger官","tags":null,"title":"Ranger使用教程","uri":"https://coder-liuu.github.io/2021/02/ranger/","year":"2021"},{"content":" 更好的使用搜索引擎的功能，可以让我们查找起东西来更快速\n 有的时候使用起来总是会忘，故总结记录一下\n假设XXX是我们的搜索内容\nGoogle   搜索某段时间之后的内容: XXX after: 2021-01-01\n  搜索某段时间之前的内容: XXX before: 2021-01-01\n  排除某个关键字: XXX -ABC\n  我们想搜索关于apple的内容,但是想排除搜索出的apple watch的内容,我们可以使用-指定排除的关键词,比如 apple -watch\nOR 和 AND: XXX AND XXX  OR: 包含OR两边的任意一个关键词,比如 apple OR watch\nAND: 包含AND两边的关键词,比如 apple AND watch\n完全匹配: \u0026ldquo;XXX1 XXX2\u0026quot;  有时候搜索引擎会将我们的搜索内容进行切分，如果我们并不想要搜索引擎对我们的关键词进行切分可以对其内容加上双引号,比如 \u0026ldquo;apple watch\u0026rdquo;\nGithub   设置指定语言: XXX language: C++\n  设置星星数量: XXX stars: \u0026gt;500\n  设置地点: XXX location:china\n  以后发现常用的，会继续更新 ","id":27,"section":"posts","summary":"更好的使用搜索引擎的功能，可以让我们查找起东西来更快速 有的时候使用起来总是会忘，故总结记录一下 假设XXX是我们的搜索内容 Google 搜索某段时间之后的","tags":null,"title":"各种搜索引擎技巧","uri":"https://coder-liuu.github.io/2021/02/search-ticks/","year":"2021"},{"content":"我的易忘点   pair头文件utility\n  无序map头文件unordered_map\n  优先队列拼写 priority_queue\n  priority_queue #include \u0026lt;queue\u0026gt; // 优先队列 头文件 // 升序队列 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; q; // 降序队列 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, less\u0026lt;int\u0026gt; \u0026gt; q; // 优先队列中结构体的排序 //重写仿函数 struct cmp_queue { bool operator() (PII a, PII b) { if(a.first \u0026gt; b.first) return true; if(a.first \u0026lt; b.first) return false; if(a.second \u0026gt; b.second) return true; return false; } }; priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;,cmp_queue\u0026gt; q; // 参考文献:https://blog.csdn.net/weixin_36888577/article/details/79937886  pair #include \u0026lt;utility\u0026gt; // 头文件 #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ pair\u0026lt;int,int\u0026gt; mm; // 创建pair mm.first = 1; // 给第一个元素赋值 mm.second = 2; // 给第二个元素赋值 cout \u0026lt;\u0026lt; mm.first \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; mm.second \u0026lt;\u0026lt; endl; }  Vector #include \u0026lt;vector\u0026gt; // 头文件 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v1; // 空vector vector\u0026lt;int\u0026gt; v2(4); // 大小为4的空vector vector\u0026lt;int\u0026gt; v3{1,2,3}; // vector内容为{1,2,3} v1.push_back(3); // 添加元素 v2.size(); // 查看大小 sort(v3.begin(),v3.end()); // 进行排序 }  Stack #include \u0026lt;stack\u0026gt; // 头文件 #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ stack\u0026lt;int\u0026gt; s; // 定义一个空栈 s.push(1); // 向栈内添加元素 s.top(); // 查看栈顶元素 s.pop(); // 出栈，无返回值 s.size(); // 查看元素个数 }  map #include \u0026lt;map\u0026gt; // 树状map,有序,按照第一个键排序 #include \u0026lt;unordered_map\u0026gt; // 哈希map,无序 #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ map\u0026lt;int,int\u0026gt; m1; unordered_map\u0026lt;int,int\u0026gt; m2; m1[1] = 1; m1[5] = 2; m1[3] = 3; cout \u0026lt;\u0026lt; \u0026quot;Map\u0026quot; \u0026lt;\u0026lt; endl; for(auto x:m1){ cout \u0026lt;\u0026lt; x.first \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; x.second \u0026lt;\u0026lt; endl; } m2[1] = 1; m2[5] = 2; m2[3] = 3; cout \u0026lt;\u0026lt; \u0026quot;unordered_Map\u0026quot; \u0026lt;\u0026lt; endl; for(auto x:m2){ cout \u0026lt;\u0026lt; x.first \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; x.second \u0026lt;\u0026lt; endl; } }  Set #include \u0026lt;set\u0026gt; // 有序set #include \u0026lt;unordered_set\u0026gt; // 无序set #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ set\u0026lt;int\u0026gt; s1; unordered_set\u0026lt;int\u0026gt; s2; s1.insert(1); // 插入元素 s2.insert(1); }  ","id":28,"section":"posts","summary":"我的易忘点 pair头文件utility 无序map头文件unordered_map 优先队列拼写 priority_queue priority_queue #include \u0026lt;queue\u0026gt; // 优先队列 头文件 // 升序队列 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; q; // 降","tags":null,"title":"STL模板总结","uri":"https://coder-liuu.github.io/2021/02/stl/","year":"2021"},{"content":"最近使用Manjaro-Gnome系统已经快过去2年了，好多使用过的软件已经忘了，最近也打算重装系统，于是准备总结一下自己常用和好用的软件，以此记录，给自己和以后需要的人。\ngoogle-chrome 浏览器 浏览器是上网的必备，没有浏览器电脑的意义也就少了些许。\n安装：sudo pacman -S google-chrome\nTim 聊天软件 身为国人QQ，乃是必备。 安装：sudo pacman -S deepin.com.qq.im\nWps 常用办公软件 在线苦逼大学生写论文做PPT需要\n安装：sudo pacman -S wps-office\nnautilus 文件管理器 类似于Windows下的资源管理器，自带工具，无需安装\n安装：sudo pacman -S nautilus\n他的孪生兄弟thunar与他相似\n安装：sudo pacman -S thunar\nfoxit PDF阅读器 科研狗或喜欢看电子书必备软件，功能强大\n安装：sudo pacman -S foxit\nvscode 代码编辑器 强大且配置简单的无敌编辑器\n安装：sudo pacman -S code\npicgo 图床软件 以前使用在线图床过了一年图都消失啊，于是经过一番搜索发现了这个基于gitee的图床 官网：https://github.com/Molunerfinn/PicGo\n安装：yay -S picgo-appimage\n配置方式：TODO\nqv2ray 科学上网软件 科学上网你懂得～ 安装：sudo pacman -S qv2ray 图片就不放了\n网易云音乐（非官方客户端） 官方的网易云音乐在linux下有一个缺点就是在搜索框中不能输入中文，无奈之下找到了这个替代品\n安装：sudo pacman -S electron-netease-cloud-music\nxmind 思维导图 工程必备，思维导图，安装的使用需要snap来安装\n安装：https://snapcraft.io/install/xmind/manjaro\nfilezilila FTP传输软件 苦逼大学生使用FTP交作业\n安装：sudo pacman -S filezilila\ncpolar内网穿透软件 想将本地端口映射到域名地址，想在局域网外SSH链接电脑，这个软件就是这个作用\n官网：https://www.cpolar.com/\n安装：官网下载\nnavicat 数据库可视化软件 以excel方式查看数据库的数据集，老好用了，缺点就是只能免费用15天\n官网：https://www.navicat.com.cn/\n安装：官网下载\ndmenu 快速启动软件 快速启动一个软件\n安装：sudo pacman -S dmenu\nwine 模拟window软件 安装：sudo pacman -S wine\nfish 下载百度文库软件 苦逼大学生必备,linux需要用wine才能打开\n下载Fish.zip密码：i1ui\ntmux 终端复用软件 这个大名鼎鼎的终端复用软件，就不必多说了。\n安装：sudo pacman -S tmux\nranger 终端下的文件管理器 终端党必备，终端下的文件管理器\n安装：sudo pacman -S ranger\nzsh 好用的shell命令解释器 bash的进阶，具有自动补全，提示，扩展性更高。\n安装：sudo pacman -S zsh\nneovim 文本编辑软件 vim爱好者的终端下编辑器\n安装：sudo pacman -S neovim\nfzf 模糊搜索工具 通过文件名字，快速搜索一个文件\n安装：sudo pacman -S fzf\nag 代码搜索工具 在众多代码文件中搜索，某个变量\n安装：sudo pacman -S the_silver_searcher\n","id":29,"section":"posts","summary":"最近使用Manjaro-Gnome系统已经快过去2年了，好多使用过的软件已经忘了，最近也打算重装系统，于是准备总结一下自己常用和好用的软件，","tags":null,"title":"Manjaro常用软件","uri":"https://coder-liuu.github.io/2021/01/manjaro-softwork/","year":"2021"},{"content":"个人认为这部分的数论中的基础，刚刚有查了查蓝桥杯不考数论，所以这篇博客的数论知识都是一些基础知识。准备蓝桥杯还是好好学学动态规划和图论吧!\n质数 质数概念: 从2开始，只包含1和本身的约数，又称素数。\n性质: 若有n整除d，则n整除d/n $$ d | n \\rightarrow \\frac{d}{n} | n $$\n1-试除法判断质数模板 bool is_prime(int n){ if(n \u0026lt; 2) return false; for(int i = 2; i \u0026lt;= n / i; i++){ if(n % i == 0) return false; } return true; }  2-分解质因数(求一个数的所有质因数) void divide(int n){ for(int i = 2; i \u0026lt;= n / i; i++){ if(n % i == 0){ int s = 0; while(n % i == 0)n /= i,s++; // i 是底数，s是指数(有多少个i) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } } if(n \u0026gt; 1) cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; }  3-筛素数(判断1-n之间有多少个素数) 普通方法:枚举1-(n-1)来看看是否能筛掉n这个数\nvoid get_primes(int n){ for(int i = 2; i \u0026lt;= n ;i++){ if(st[i] == false){ ans++; } for(int j = i + i; j \u0026lt;= n; j+=i){ st[j] = true; } } }  埃氏方法:枚举1-(n-1)中的质数来看看是否能筛掉n这个数\nvoid get_primes(int n){ for(int i = 2; i \u0026lt;= n ;i++){ if(st[i] == false){ ans++; for(int j = i + i; j \u0026lt;= n; j+=i){ st[j] = true; } } } }  线性方法:使用n的最小质因数来筛掉n\nvoid get_primes(int n){ for(int i = 2; i \u0026lt;= n ;i++){ if(!st[i]) primes[ans++] = i; for(int j = 0; primes[j] \u0026lt;= n / i; j++){ st[primes[j] * i] = true; if(i % primes[j] == 0) break; } } }  4-试除法求约数 vector\u0026lt;int\u0026gt; get_divisors(int x) { vector\u0026lt;int\u0026gt; res; for (int i = 1; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { res.push_back(i); if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; }  5-约数相关公式 如果约数: $ N = p_{1}^{a1} * p_{2}^{a2} *\u0026hellip;* p_{k}^{ak} $\n约数个数: $ (a_{1} + 1) * (a_{2} + 2) * \u0026hellip; * (a_{k} + 1)$\n约数之和: $ (p_{1}^0 +p_{1}^1 +\u0026hellip; +p_{1}^{a1}) * \u0026hellip; * (p_{k}^0 +p_{k}^1 +\u0026hellip; +p_{k}^{ak}) $\n6-欧几里得算法(辗转相除法求最小公因数) int gcd(int a,int b){ return b ? gcd(b,a % b):a; }  7-求欧拉函数 定义: 1-N中于N互质的个数被称为欧拉函数，记为$ \\phi(N)$\n如果约数: $ N = p_{1}^{a1} * p_{2}^{a2} *\u0026hellip;* p_{k}^{ak} $\n求法: $ \\phi(N) = N * (1 - \\frac{1}{p_1}) * (1 - \\frac{1}{p_2}) * \u0026hellip; * (1 - \\frac{1}{p_k}) $\n8-筛法求欧拉函数 通过线性筛求很多欧拉函数\nint primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } }  9-快速幂 求$m^k \\mod p$ 时间复杂度logk\nLL f(LL a,LL b,LL p){ LL res = 1; while(b){ if(b \u0026amp; 1) res = (res * a) % p; a = (a * a) % p; b\u0026gt;\u0026gt;=1; } return res % p; }  10-求组合数 朴素求组合数,适用范围0-1000以内左右的组合数\nconst int N = 1010; int C[N][N]; for(int i = 0; i \u0026lt; N; i++){ for(int j = 0; j \u0026lt;= i; j++){ if(!j) C[i][j] = 1; else C[i][j] = C[i-1][j] + C[i-1][j-1]; } }  ","id":30,"section":"posts","summary":"个人认为这部分的数论中的基础，刚刚有查了查蓝桥杯不考数论，所以这篇博客的数论知识都是一些基础知识。准备蓝桥杯还是好好学学动态规划和图论吧! 质","tags":null,"title":"ACM数论","uri":"https://coder-liuu.github.io/2021/01/acm-math/","year":"2021"},{"content":"一、用Python第三方库virtualenv创建虚拟环境 这种方式是最原始最简单的一种方式.个人经常使用\n1. 安装方式 pip install virtualenv # python2 pip3 install virtualenv # python3  2.创建虚拟环境 virtualenv [虚拟环境的名字]  .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Tip\n这个虚拟环境会在你所在的目录生成，这里建议将所有的虚拟环境放在同一个目录下，容易管理\n 3.进入退出虚拟环境 linux进入虚拟环境 source /path/to/virtualenv/bin/activate\nlinux退出虚拟环境 deactivate\n4.安装所需的第三方库 当你进入虚拟环境，使用方式和pip的使用方法就都是一样的了。例如安装numpy库就是这样的命令pip3 install numpy\n5. 创建时指定python版本 创建时指定python版本需要加上-p选项,然后后面加上python的路径,比如这样: virtualenv -p /usr/bin/python3 py3env\n二、用Anaconda创建虚拟环境 这种方式是的优点是自动管理虚拟环境的目录，缺点就是安装的时候有点慢。 Warning\nconda是Anaconda里的一个工具，只有安装了Anaconda才会有的。\n 1. 创建虚拟环境 conda create -n ENV python==3.6  2. 激活/退出虚拟环境 激活虚拟环境 conda activate ENV\n退出虚拟环境 conda deactivate\n3. 安装所需的第三方库 conda install -n ENV [package]\n4. 查看conda环境下所有的虚拟环境 conda info --envs\n三、更换镜像源 1. pip 临时换源 pip install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple  2. Conda更换镜像源(Windows) conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/  3. Conda更换镜像源(Linux) 将以上配置文件写在~/.condarc中\nchannels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ ssl_verify: true  四、导出依赖包 1.导出当前环境下,所有的库 pip freeze \u0026gt; requirements.txt\n2.只导出所在项目的依赖包 # 安装pipreqs pip install pipreqs # 进行导出 pipreqs ./  3. 通过依赖包安装 pip install -r requirements.txt  参考博客 https://www.cnblogs.com/shyern/p/11284127.html\nhttps://www.cnblogs.com/shuaiyin/p/10922467.html\n","id":31,"section":"posts","summary":"一、用Python第三方库virtualenv创建虚拟环境 这种方式是最原始最简单的一种方式.个人经常使用 1. 安装方式 pip install virtualenv # python2 pip3 install virtualenv # python3 2.创","tags":null,"title":"Python-创建虚拟环境","uri":"https://coder-liuu.github.io/2020/04/python-create-vir/","year":"2020"},{"content":"最常用篇   初始化git仓库 git init\n  添加修改 git add .\n  删除git仓库,只需要删除本地的文件就可以了 rm -rf .git\n  查看当前仓库的状态 git status\n  丢弃工作区的改动 git restore \u0026lt;文件\u0026gt;\n  回滚撤回提交操作 git reset\n  告诉Git你是谁 git config --global user.name \u0026quot;Liu Yang\u0026quot;\n  提交东西 git commit -m \u0026quot;some describle\u0026quot; 如果这时候没有-m 和后面的东西将进入一个界面然后可以继续写自己的描述，修改后自动被提交\n  .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Tip\ngit commit \u0026ndash;amend 可以将这次提交追加到上一次提交中去，减少不必要的提交\n   配置默认编辑器git config --global core.editor nvim\n  让Git忽略一些东西，不被追踪 首先先新建一个文件.gitignore，然后将要忽略的文件写在上面就好了\n  让Git停止跟踪一个文件 git rm --cached ×××××\n  Git回滚篇   查看日志 git log\n  回滚到指定版本 git reset --hard id\n  回滚后看全部的历史提交记录 git reflog\n  删除git commit记录 git rebase -i xxxxxx(提交记录id),然后进入一个vim界面，把想删除的pick,改成drop保存退出，提交记录就没有了\n  高级篇   列出本地分支 git branch\n  添加一个分支 git branch xx(xx为分支名)\n  切换分支 git checkout xx(xx为分支名)\n  合并分支 git merge xx(xx为分支名)\n  添加远程仓库 git remote add origin xxx(xxx为网址)\n  解除远程仓库 git remote remove origin\n  提交到远程仓库里 git push --set-upstream origin master (!!! 本地至少的提交一次)\n  克隆仓库 git clone xxx(xxx为网址)\n  让Git记住你的帐号密码 git config credential.helper store\n  更新仓库,别人帮你做过修改，然后来更新自己的本地文件 git pull\n  在Github仓库的设置中可以邀请伙伴一起完成项目。\n  Git 查看自己的远程仓库git remote -v\n  Git其他常见操作 使用Git来提交一个PR  fork到自己仓库 git clone 到本地 上游建立连接  git remote add upstream 开源项目地址 创建并切换分支 git checkout -b new-xiaoming 提交代码 push到自己的仓库中去 去自己仓库的主页发现多了一个PR的按钮  不同时推送到gitee和github git remote add gitee https://gitee.com/monksoul/Fur.git git remote add github https://github.com/MonkSoul/Fur.git git push gitee git push github  同时推送到gitee和github gitee项目地址是:https://gitee.com/liu__yang/clustering-system\ngithub项目地址是https://github.com/Dreamer-liuyang/simple-clustering-system\n使用下面的命令关联两个数据库\ngit remote add origin https://gitee.com/xueleilei/nuxt-ssr-template.git git remote set-url --add origin https://github.com/xueleilei/nuxt-ssr-template.git git push  最后push时会同时push到两个仓库中\n推荐教程 练习网站 猴子教程 官方的中文文档\n","id":32,"section":"posts","summary":"最常用篇 初始化git仓库 git init 添加修改 git add . 删除git仓库,只需要删除本地的文件就可以了 rm -rf .git 查看当前仓库的状态 git status 丢弃工作区的改动 git restore \u0026lt","tags":null,"title":"Git命令总结","uri":"https://coder-liuu.github.io/2020/04/git-summary/","year":"2020"}],"tags":[]}