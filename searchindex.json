{"categories":[{"title":"ACM","uri":"https://coder-liuu.github.io/categories/acm/"},{"title":"Linux","uri":"https://coder-liuu.github.io/categories/linux/"},{"title":"机器学习","uri":"https://coder-liuu.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"title":"电影与书籍","uri":"https://coder-liuu.github.io/categories/%E7%94%B5%E5%BD%B1%E4%B8%8E%E4%B9%A6%E7%B1%8D/"},{"title":"默认分类","uri":"https://coder-liuu.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"}],"posts":[{"content":" KMeans完整代码想抄作业的同学直接点这里\n 一、KMeans算法简介 KMeans是经典的聚类算法\n假设要在一个新的城市中，开几个大型商场，应该怎样选址才能吸引更多客户呢？如果显然都商场都建立在郊区不是最好的选择，但是商场都建立市中心也不是最好的选择。其中一种解决方案就使所有居民距离自己区域的商场距离最近。\nKMeans算法，主要由两部分组成：\n 初始聚类中心的选择 聚类中心的迭代更新  二、初始聚类中心的选择 随机选择 随机选择是最简单的一种初始化聚类中心的方法，其步骤就是随机从数据中选取K个样本，作为初始的聚类中心。\nk-means++ k-means++的步骤是：先随机选取一个点，然后在选择下一个点时，选择与已选择点距离最远的样本点。可以说\u0026quot;k-means++\u0026ldquo;是一种倾向于选择相互距离较远的样本点最为初始点(这个初始化的方法目前，没有在代码中实现)\n三、聚类中心的迭代更新 Kmeans算法的目标为: 找到合适的聚类中心，使得所有样本到其分组中心的距离的平方最小，用数学公式表达，假设有N个样本，K个聚类中心，Kmeans的目标为:\n$$ E = \\sum_{i=1}^{k} \\sum_{x \\in C_i } distant(x - \\mu_i) ^ 2 $$\n其中，$ \\mu_i = \\frac{1}{C_i} \\sum{}{x \\in C_i } $，$\\mu_i$是簇$C_i$的均值向量。\n如果直接求最合适的聚类中心，很难，这是一个NP难问题，因此K-means算法采用贪心策略通过迭代来求近似最优解。\n算法流程如下所示:\n我们可以将书中的伪代码，进一步抽象可以分为下面几个步骤\n 计算每个样本与每个聚类中心的距离 将样本划分到距离样本最近的聚类簇当中去 重新计算聚类中心点向量 如果新聚类中心点向量 跟 旧的聚类中心点向量不一样，更新聚类中心点向量 如果一样或者达到最大迭代次数，算法完毕  举个例子\n西瓜数据集如下所示，手动模拟Kmeans算法，将数据集聚类成2类.\n   样本编号 密度 重量     1 1 3   2 1 4   3 3 5   4 5 5    步骤0: 随机选择两个样本作为聚类中心点\n假设选择样本编号为1,2的样本最为初始聚类中心点\n$\\mu_1 = {1,3} $ $\\mu_2 = {1,4} $\nCenter = {{1,3},{1,4}}\n步骤1: 计算每个样本到聚类中心点的距离\n   欧式距离平方 $\\mu_1$ $ \\mu_2$     样本1 0 1   样本2 1 0   样本3 4+4=8 4+1=5   样本4 16+4=20 16+1=17    步骤2: 将样本划分到距离样本最近的聚类簇当中去\n聚类簇1的样本为 {样本1}\n聚类簇2的样本为 {样本2,样本3,样本4}\n步骤3: 重新计算聚类中心点向量\n$\\mu_1 = {1,3} $ $\\mu_2 = {3,4.66} $\n步骤4: 判断新聚类中心是否和旧聚类中心一样\n答案不一样，继续执行步骤1\n第二轮,步骤1: 计算每个样本到聚类中心点的距离\n.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Warning\n注意这里$ \\mu $ 已经更新了\n    欧式距离平方 $\\mu_1$ $ \\mu_2$     样本1 0 4+2.56=6.56   样本2 1 4+0.36=4.36   样本3 4+4=8 0+0.09=0.09   样本4 16+4=20 4+0.09=4.99    第二轮，步骤2: 将样本划分到距离样本最近的聚类簇当中去\n聚类簇1的样本为 {样本1,样本2}\n聚类簇2的样本为 {样本3,样本4}\n第二轮，步骤3: 重新计算聚类中心点向量\n$\\mu_1 = {1,3.5} $\n$\\mu_2 = {4,5} $\n第二轮，步骤4: 判断新聚类中心是否和旧聚类中心一样\n答案不一样，继续执行步骤1\n第三轮,步骤1: 计算每个样本到聚类中心点的距离\nWarning\n注意这里$ \\mu $ 又更新了\n    欧式距离平方 $\\mu_1$ $ \\mu_2 $     样本1 0.25 9+4=13   样本2 0.25 9+1=10   样本3 4+2.25=6.25 1+0=1   样本4 16+2.25=18.25 1+0=1    第三轮，步骤2: 将样本划分到距离样本最近的聚类簇当中去\n聚类簇1的样本为 {样本1,样本2}\n聚类簇2的样本为 {样本3,样本4}\n第二轮，步骤3: 重新计算聚类中心点向量\n$\\mu_1 = {1,3.5} $\n$\\mu_2 = {4,5} $\n第三轮，步骤3: 重新计算聚类中心点向量\n$\\mu_1 = {1,3.5} $\n$\\mu_2 = {4,5} $\n第三轮，步骤4: 判断新聚类中心是否和旧聚类中心一样\n答案一样，迭代结束\n结果: 聚类中心点为\n$C_1 = {1,3.5}$\n$C_2 = {4,5}$\n算法结束\n四、探索性问题 留给几个问题，可供读者思考.\n Kmeans怎么对数据集属性进行加权?  ","id":0,"section":"posts","summary":"KMeans完整代码想抄作业的同学直接点这里 一、KMeans算法简介 KMeans是经典的聚类算法 假设要在一个新的城市中，开几个大型商场，应该","tags":null,"title":"动手机器学习-\u003e实现KMeans算法","uri":"https://coder-liuu.github.io/2021/03/ml-kmeans/","year":"2021"},{"content":" 程序员的人生不止代码，还应有诗和远方\n  人生就像巧克力，永不知道下一块是什么味道。  人物   阿甘虽然笨，但是专心，可以说是专心和运气成就了自己，每一次都十分专心的去做一件事。而在现在的我们，总有三分热度的感觉，对于技术工作来说，如果把一个技术做到精通可以说很难得，同时阿甘每次都能选择正确的方向（有一些不现实）。\n  这个电影中给我印象最深的就是巴布，巴布世代为奴，最大的梦想就是成为捕虾船的船长，这点梦想跟阿甘所做的微不足道，但是巴布没有主角光环，非常的不幸，在越南中牺牲了。\n  其次就是丹中尉，丹中尉出生于军人世家，疼爱下属，是一个非常棒的长官，在指挥上非常出色。但是其经历挫折后自暴自弃，这个挫折与丹中尉的价值观非常不符，如果换作是我的话，我可能也很难走出来。不过还好，最终丹中尉走出困境，通过新的技能开辟了一番新的天地。\n  而珍妮，有着仿佛鸣人一般的激情，却总是失败，只能说命运不好。自己梦想成为一名音乐家，如果珍妮最初选择了简单的一步一个脚印的发展自己的音乐，也应会取得一定的成就把\n  感受  1.甘的人生9分天注定，Bubba的也是。只是一个好命，一个惨命。\n2.Dan和Jenny是4分天注定，6分靠选择。只是一个选对了，另一个没选对。\n3.绝大多数人都只能是Jenny 和 Bubba，少数人成为Dan，但是想活成阿甘，万中无一。\n4.“随遇、随缘、随安、随喜”\n ","id":1,"section":"posts","summary":"程序员的人生不止代码，还应有诗和远方 人生就像巧克力，永不知道下一块是什么味道。 人物 阿甘虽然笨，但是专心，可以说是专心和运气成就了自己，每一次","tags":null,"title":"阿甘正传","uri":"https://coder-liuu.github.io/2021/03/%E9%98%BF%E7%94%98%E6%AD%A3%E4%BC%A0/","year":"2021"},{"content":"正文  Linux也可以制作U盘启动盘,而且不需要使用其他外部工具,非常简单\n  使用命令sudo fdisk -l,找到自己U盘  执行结果中一般最后一个Disk是自己的U盘,当然也需要自己额外注意一下磁盘大小和U盘大小是否相匹配,防止后面出现问题.\n使用sudo umont /dev/sdb,卸载自己的U盘 使用sudo mkfs.vfat /dev/sdb -I,格式化自己的U盘 制作启动盘  命令如下所示:\nsudo dd if=~/Downloads/ubuntu-16.04-desktop-amd64.iso of=/dev/sdb status=progress  参考文章 李空空\n","id":2,"section":"posts","summary":"正文 Linux也可以制作U盘启动盘,而且不需要使用其他外部工具,非常简单 使用命令sudo fdisk -l,找到自己U盘 执行结果中一般最后一个Disk是","tags":null,"title":"Linux下使用dd命令制作启动盘","uri":"https://coder-liuu.github.io/2021/03/linux-dd/","year":"2021"},{"content":" 决策树完整代码想抄作业的同学直接点这里\n 一、决策树简介 决策树是一个很简单的机器学习算法,可以看作if-then的集合,比如我们判断一个西瓜的好坏?我们很可能通过一系列的问题进行判断,比如首先我们问西瓜是绿色的吗?如果是接下来问西瓜甜不甜呢？这就是一颗决策树.\n决策树算法,主要由两部分组成:\n 划分选择 决策树的生成  下面，将从这两方面进行介绍，并提供对应的python代码，以及手写一颗决策树.\n二、划分选择 我们首先要想西瓜的哪个特征对结果影响最大呢?也就是说，先问最关键的问题. 这时候需要引入一个概念信息增益\n在介绍信息增益前，先要了解信息熵是什么?\n信息熵(entropy): 是度量样本集合纯度的一种最常用的指标，简单说就是这是事件的不确定性的大小，熵越大事件就越不确定，熵为0时，说明这是一个确定性事件。\n计算方法: $$ D = [P_1,P_2,\u0026hellip;,P_n] $$ $$ Ent(D) = -\\sum_{i=1}^n P_i log_2P_i $$\n计算示例1: 有一个不均匀硬币,其中正面向上的概率为$\\frac{1}{3}$,反面向上的概率也是$\\frac{2}{3}$,则该事件的熵的计算公式如下:\n$$ Ent(D) = - ( \\frac{1}{3} log_2\\frac{1}{3} + \\frac{2}{3} log_2\\frac{2}{3} ) = 0.918$$\n计算示例2: 有一个均匀硬币,其中正面向上的概率为$\\frac{1}{2}$,反面向上的概率也是$\\frac{1}{2}$,则该事件的熵的计算公式如下:\n$$ Ent(D) = - ( \\frac{1}{2} log_2\\frac{1}{2} + \\frac{1}{2} log_2\\frac{1}{2} ) = 1 $$\n可以看到均匀硬币,有更大的信息熵,所以均匀硬币不确定的结果也就越大。\n接下来就可以说一下信息增益了，信息增益就是得知信息A而使事件D不确定性，减小的程度，用公式表示为$ g(D,X) = Ent(D) - Ent(D|A) $.\n举个例子：假如刚开始有一枚硬币，我们认为硬币是均匀的，所以信息熵为1,但是经过测量我们发现硬币是不均匀的，不均匀程度如上面的计算示例1所示,所以现在的信息熵为0.918.最终我们知道了这个信息的信息增益为$1-0.918=0.082$\n计算信息熵的代码如下所示:\nimport numpy as np def entropy(y): # y是事件的结果，比如抛硬币1次正，2次反.y就为[1,2,2] hist = np.bincount(y) ps = hist / np.sum(hist) return -np.sum([p * np.log2(p) for p in ps if p \u0026gt; 0])  三、决策树的生成 决策树的种类有多种多样，先放一个通用的决策树的为代码,其中红色标注的我们已经学会了\n我们可以将书中的伪代码，进一步抽象可以分为下面几个步骤\n 如果数据集中样本为同一类别或者没有特征可以继续划分，停止划分为叶结点赋值 选择最优划分属性 以最优属性将原数据集分为两个数据集，递归构建决策树  接下来我们说一下决策树中经典算法ID3算法，其实不同的决策树主要的区别就在于第2步,ID3算法使用信息增益来作为评价最优属性的标准。\n举个例子\n数据集如下所示，使用ID3算法构建决策树.\n   编号 敲声 颜色 好瓜     1 响 绿色 是   2 不响 绿色 是   3 响 黄色 不是    步骤1: 查看数据集是否都是同一类别,答案不是\n步骤2: 寻找最优划分属性 初始信息熵为: $$ Ent = -(\\frac{2}{3} log_2 \\frac{2}{3} + \\frac{1}{3} log_2 \\frac{1}{3}) = 0.918 $$\n假设以敲声划分，敲声响中(1好瓜,1坏瓜),敲声不响中(1好瓜,0坏瓜)，计算公式如下所示:\n$$ Ent(敲声) = - \\frac{2}{3} (\\frac{1}{2} log_2 \\frac{1}{2} + \\frac{1}{2} log_2 \\frac{1}{2}) - \\frac{1}{3} (\\frac{1}{1} log_2 \\frac{1}{1} + \\frac{0}{1} log_2 \\frac{0}{1}) = 0.666 + 0 = 0.666 $$\n.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Warning\n在计算的过程中，规定$\\frac{0}{1} log_2 \\frac{0}{1} = 0$\n 假设以颜色划分，绿色中(2好瓜,0坏瓜),黄色中(0好瓜,1坏瓜)，计算公式如下所示:\n$$ Ent(颜色) = - \\frac{2}{3} (\\frac{2}{2} log_2 \\frac{2}{2} + \\frac{0}{2} log_2 \\frac{0}{2}) - \\frac{1}{3} (\\frac{0}{1} log_2 \\frac{0}{1} + \\frac{1}{1} log_2 \\frac{1}{1}) = 0 + 0 = 0$$\n敲声的信息增益为: $ 0.918 - 0.666 = 0.252 $\n颜色的信息增益为: $ 0.918 - 0 = 0.918 $\n所以颜色为决策树的根节点，接下来我们考虑该节点的儿子节点.\n步骤3: 划分数据集\n使用颜色划分数据集，划分规则是相同颜色的数据为一个数据集。\n即下标为1,2的是数据集S1,下标为3的是数据集S2\n步骤4: 查看数据集S1,S2是否都是同一类别,答案是,所以停止划分,我们发现数据集S1全部为好瓜所以该节点为绿色,而另一个节点为坏瓜,最终决策树如下图所示:\n四、探索性问题 留给几个问题，可供读者思考.\n 决策树怎么处理连续值？ 决策树怎么进行剪枝?  ","id":3,"section":"posts","summary":"决策树完整代码想抄作业的同学直接点这里 一、决策树简介 决策树是一个很简单的机器学习算法,可以看作if-then的集合,比如我们判断一个西瓜的好","tags":null,"title":"动手机器学习-\u003e实现决策树","uri":"https://coder-liuu.github.io/2021/02/ml-decision-tree/","year":"2021"},{"content":"快速排序 时间复杂度: $O(nlog(n))$,模板题\nvoid quick_sort(int q[],int l,int r){ if(l \u0026gt;= r) return; // 1. 寻找分界点 int x = q[(l + r)/2],i = l - 1, j = r + 1; // 2. 调整区间 while(i \u0026lt; j){ do i++; while(q[i] \u0026lt; x); do j--; while(q[j] \u0026gt; x); if(i \u0026lt; j) swap(q[i],q[j]); } // 3. 分布递归 quick_sort(q,l,j); quick_sort(q,j+1,r); }  归并排序 时间复杂度: $O(nlog(n))$,模板题\nvoid merge_sort(int q[],int l,int r){ if(l \u0026gt;= r) return; // 1. 确定分界点 int mid = (l + r) \u0026gt;\u0026gt; 1; // 2. 进行递归 merge_sort(q,l,mid); merge_sort(q,mid+1,r); // 3. 合并区间 int k = 0, i = l, j = mid + 1; while(i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if(q[i] \u0026lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while(i \u0026lt;= mid) tmp[k++] = q[i++]; while(j \u0026lt;= r) tmp[k++] = q[j++]; for(i = l, j = 0; i \u0026lt;= r; i++, j++) q[i] = tmp[j]; }  二分查找 bool check(int x); // 检查x是否满足某种性质 // 最小满足点: 若mid满足搜索[l,mid],否则搜索[mid+1,r] // 一段区间，开始不满足后来满足 int bsearch_low(int l,int r){ while(l \u0026lt; r){ int mid = l + r \u0026gt;\u0026gt; 1; if( check(mid) ) r = mid; else l = mid + 1; } } // 最大满足点: 若mid满足搜索[mid,r],否则搜索[l,mid-1] // 一段区间，开始满足后来不满足 int bsearch_high(int l,int r){ while(l \u0026lt; r){ int mid = l + r + 1 \u0026gt;\u0026gt; 1; if( check(mid) ) l = mid; else r = mid - 1; } }  高精度加法模板 需要注意的是： A是一个从低位到高位的数组，比如A是[1,2,3],代表的值是321\nvector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A,vector\u0026lt;int\u0026gt; \u0026amp;B){ vector\u0026lt;int\u0026gt; C; int t = 0; for(int i = 0; i \u0026lt; A.size() || i \u0026lt; B.size(); i++){ if(i \u0026lt; A.size()) t += A[i] - '0'; if(i \u0026lt; B.size()) t += B[i] - '0'; C.push_back(t % 10); t /= 10; } if(t) C.push_back(1); return C; }  高精度减法模板 vector\u0026lt;int\u0026gt; sub(v \u0026amp; A, v \u0026amp; B){ for(int i = 0; i \u0026lt; A.size() ; i++){ A[i] -= B[i]; if(A[i] \u0026lt; 0){ A[i] += 10; A[i+1] -= 1; } } // 去掉前导0 while(A.size() \u0026gt; 1 \u0026amp;\u0026amp; A.back() == 0) A.pop_back(); return A; }  ","id":4,"section":"posts","summary":"快速排序 时间复杂度: $O(nlog(n))$,模板题 void quick_sort(int q[],int l,int r){ if(l \u0026gt;= r) return; // 1. 寻找分界点 int x = q[(l + r)/2],i = l - 1, j = r + 1; // 2. 调整区间 while(i \u0026lt; j){ do i++; while(q[i] \u0026lt;","tags":null,"title":"ACM基础算法模板","uri":"https://coder-liuu.github.io/2021/02/acm-base/","year":"2021"},{"content":"朴素的Dijkstra算法 求点之间距离不相同的最短路算法\n时间复杂度$O(n^2+m)$,n表示点数,m表示边数,模板题\nint g[N][N]; // 存储图 int dist[N]; // 1号点到每个点的距离 int st[N]; // 是否已经确定为最小距离 int n,m; // 点数 边数 int dijkstra(){ // 初始化距离 memset(dist,0x3f,sizeof(dist)); dist[1] = 0; for(int i = 0; i \u0026lt; n - 1; i++){ // 找到没有在集合st中，距离起点最近的点 int t = -1; for(int j = 1; j \u0026lt;= n; j++) if(!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; // 更新距离 for(int j = 1; j \u0026lt;= n; j++) dist[j] = min(dist[j],dist[t] + g[t][j]); // 将该点加入st中 st[t] = true; } return dist[n] == 0x3f3f3f3f ? -1 : dist[n]; }  朴素的Prim算法 求图中的最小生成树算法\n时间复杂度$O(n^2+m)$,n表示点数,m表示边数,模板题\nconst int N = 550, INF = 0x3f3f3f3f; int g[N][N], st[N], dist[N]; int n,m; int prim(){ // 初始化到集合的距离 memset(dist,0x3f,sizeof dist); int res = 0; for(int i = 0; i \u0026lt; n; i++){ // 寻找到集合最近的点 int t = -1; for(int j = 1; j \u0026lt;= n; j++) if(!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; // 如果不是第一个点，并且距离为正无穷 // 返回正无穷，也就是没有最小生成树 if(i \u0026amp;\u0026amp; dist[t] == INF) return INF; // 距离相加 if(i) res += dist[t]; st[t] = true; // 更新距离 for(int j = 1; j \u0026lt;= n; j++) dist[j] = min(dist[j],g[t][j]); } return res; }  tarjan算法 求图中的强联通分量\nint dfn[N], low[N]; // 高低数组 int stk[N], top, ts; // 模拟栈 bool in_stk[N]; // 是否在栈中 void tarjan(int now){ // 0. 准备遍历now这个点 dfn[now] = low[now] = ++ ts; stk[++top] = now, in_stk[now] = true; for(int to:v[now]){ // 1. 看看下一个点是否能更新当前点的时间戳 if(!dfn[to]){ tarjan(to); low[now] = min(low[now],low[to]); } // 2. 下一个点在栈中，看看能否更新当前点的时间戳 else if(in_stk[to]) low[now] = min(low[now],low[to]); } // 3. 将当前节点进行出栈 if(dfn[now] == low[now]){ int y,cnt = 0; do{ y = stk[top --]; in_stk[y] = false; }while(y != now); } }  ","id":5,"section":"posts","summary":"朴素的Dijkstra算法 求点之间距离不相同的最短路算法 时间复杂度$O(n^2+m)$,n表示点数,m表示边数,模板题 int g[N][N]; // 存储图 int dist[N]; // 1号","tags":null,"title":"图论知识总结","uri":"https://coder-liuu.github.io/2021/02/acm-argph-theory/","year":"2021"},{"content":" Manjaro怎么更新DNS呢?默认终端怎么改?怎么在终端下播放音乐?等等一系列问题\n 更新DNS缓存 查看DNS网址,网址\n修改Hosts文件: vim /etc/hosts\n刷新dns: sudo systemctl restart NetworkManager.service\n各种系统更新DNS缓存的方法-\u0026gt;点我出发\nArch有网络,浏览器无法访问 重启网络: systemctl restart systemctl-networkd\nManjaro-gnome设置默认终端 将alaritty设置为我的默认终端,命令: gsettings set org.gnome.desktop.default-applications.terminal exec alaritty\n终端下播放音乐 介绍:SOX软件,支持很多格式的音频文件,如 WAV,MP3,MPG,OGG,FLAC 等等.\nArch安装: sudo pacman -S sox\n使用方法: play xxx.mp3\nLinux符号连接的层数过多 ln软链接用法: ln -s 源文件 目标文件\n但是有时候我们软链接文件夹，会提示我们Linux符号连接的层数过多\n解决办法:将相对路径替换成绝对路径\n","id":6,"section":"posts","summary":"Manjaro怎么更新DNS呢?默认终端怎么改?怎么在终端下播放音乐?等等一系列问题 更新DNS缓存 查看DNS网址,网址 修改Hosts文件: vim","tags":null,"title":"Manjaro-DNS等问题.md","uri":"https://coder-liuu.github.io/2021/02/manjaro-some-problem/","year":"2021"},{"content":" ranger是一款终端下的文件管理器,具有Vim式的操作方式.\n 我曾无数次安装ranger,也曾无数次配置ranger.\n1.安装 Ranger官网上有更加丰富的介绍,本文针对少数常用功能进行介绍.\n  Arch/Manjaro安装: sudo pacman -S ranger\n  Ubuntu安装: sudo apt install ranger\n  Pip安装: pip install ranger-fm\n  当然你也可以下载源代码进行手动安装\n  最终在终端下输入ranger即可打开程序了\n2.使用 使用h,j,k,l来进行光标的移动,来穿越在不同的文件夹中\n使用q进行退出程序,使用S来进行当前光标所在的文件夹中(进入文件夹后终端下执行exit命令重新回到ranger程序当中去)\n3.配置 我相当推荐你去配置自己的ranger,因为这样ranger会对你更加的友好、舒服.\n使用ranger --copy-config=all将在~/.config/ranger中生成一系列配置文件,其中ranger主要有4个配置文件.\n rc.conf 常用于设置选项和绑定快捷键.(最常用) scope.sh 常用于设置文件的预览方式. rifle.conf 常用于设置使用那个软件来打开文件. commands.py python文件,增强和改进ranger的各种功能.  我们最常用的就是绑定快捷键了,下面我们说一说怎么在rc.conf文件中自定义我们的快捷键. 一般来说,我习惯将我自己定义的快捷键放到文件的末尾.我们以自定义创建文件夹快捷键为例.\n在文件的最后写入:map mk console shell mkdir%space\nmap: 是一个映射的关键字\nmk: 我们自定义的快捷键为mk\nconsole shell: 告诉系统我们接下来打算映射shell指令\nmkdir%space: 映射的shell命令为mkdir,其中%space为一个空格而已\nFAQ Ranger图片预览问题解决 如果觉得自己的配置文件已经被更改的乱七八糟了,请使用ranger --copy-config=all回到最初的起点.\n安装ueberzug软件作为图片预览的程序.使用Manjaro命令如下sudo pacman -S neberzug,接下来修改ranger的rc.confg配置文件,主要改动的几行改动完如下所示:\nset preview_images true set preview_images_method ueberzug set draw_borders true  最终重新启动,大工告成!\nRanger视频预览图功能  安装ffmpegthumbnailer用来生成视频预览图,Manjaro安装方式为:sudo pacman -S ffmpegthumbnailer 在scope.sh中，注释掉ffmpegthumbnailer这一块代码的内容 安装mplayer,可以更好的观看视频,我安装还是使用pacman啦~  相关资料 https://zhuanlan.zhihu.com/p/105731111\n","id":7,"section":"posts","summary":"ranger是一款终端下的文件管理器,具有Vim式的操作方式. 我曾无数次安装ranger,也曾无数次配置ranger. 1.安装 Ranger官","tags":null,"title":"Ranger使用教程","uri":"https://coder-liuu.github.io/2021/02/ranger/","year":"2021"},{"content":" 更好的使用搜索引擎的功能，可以让我们查找起东西来更快速\n 有的时候使用起来总是会忘，故总结记录一下\n假设XXX是我们的搜索内容\nGoogle   搜索某段时间之后的内容: XXX after: 2021-01-01\n  搜索某段时间之前的内容: XXX before: 2021-01-01\n  排除某个关键字: XXX -ABC\n  我们想搜索关于apple的内容,但是想排除搜索出的apple watch的内容,我们可以使用-指定排除的关键词,比如 apple -watch\nOR 和 AND: XXX AND XXX  OR: 包含OR两边的任意一个关键词,比如 apple OR watch\nAND: 包含AND两边的关键词,比如 apple AND watch\n完全匹配: \u0026ldquo;XXX1 XXX2\u0026quot;  有时候搜索引擎会将我们的搜索内容进行切分，如果我们并不想要搜索引擎对我们的关键词进行切分可以对其内容加上双引号,比如 \u0026ldquo;apple watch\u0026rdquo;\nGithub   设置指定语言: XXX language: C++\n  设置星星数量: XXX stars: \u0026gt;500\n  设置地点: XXX location:china\n  以后发现常用的，会继续更新 ","id":8,"section":"posts","summary":"更好的使用搜索引擎的功能，可以让我们查找起东西来更快速 有的时候使用起来总是会忘，故总结记录一下 假设XXX是我们的搜索内容 Google 搜索某段时间之后的","tags":null,"title":"各种搜索引擎技巧","uri":"https://coder-liuu.github.io/2021/02/search-ticks/","year":"2021"},{"content":"我的易忘点   pair头文件utility\n  无序map头文件unordered_map\n  优先队列拼写 priority_queue\n  priority_queue #include \u0026lt;queue\u0026gt; // 优先队列 头文件 // 升序队列 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; q; // 降序队列 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, less\u0026lt;int\u0026gt; \u0026gt; q; // 优先队列中结构体的排序 //重写仿函数 struct cmp_queue { bool operator() (PII a, PII b) { if(a.first \u0026gt; b.first) return true; if(a.first \u0026lt; b.first) return false; if(a.second \u0026gt; b.second) return true; return false; } }; priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;,cmp_queue\u0026gt; q; // 参考文献:https://blog.csdn.net/weixin_36888577/article/details/79937886  pair #include \u0026lt;utility\u0026gt; // 头文件 #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ pair\u0026lt;int,int\u0026gt; mm; // 创建pair mm.first = 1; // 给第一个元素赋值 mm.second = 2; // 给第二个元素赋值 cout \u0026lt;\u0026lt; mm.first \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; mm.second \u0026lt;\u0026lt; endl; }  Vector #include \u0026lt;vector\u0026gt; // 头文件 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v1; // 空vector vector\u0026lt;int\u0026gt; v2(4); // 大小为4的空vector vector\u0026lt;int\u0026gt; v3{1,2,3}; // vector内容为{1,2,3} v1.push_back(3); // 添加元素 v2.size(); // 查看大小 sort(v3.begin(),v3.end()); // 进行排序 }  Stack #include \u0026lt;stack\u0026gt; // 头文件 #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ stack\u0026lt;int\u0026gt; s; // 定义一个空栈 s.push(1); // 向栈内添加元素 s.top(); // 查看栈顶元素 s.pop(); // 出栈，无返回值 s.size(); // 查看元素个数 }  map #include \u0026lt;map\u0026gt; // 树状map,有序,按照第一个键排序 #include \u0026lt;unordered_map\u0026gt; // 哈希map,无序 #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ map\u0026lt;int,int\u0026gt; m1; unordered_map\u0026lt;int,int\u0026gt; m2; m1[1] = 1; m1[5] = 2; m1[3] = 3; cout \u0026lt;\u0026lt; \u0026quot;Map\u0026quot; \u0026lt;\u0026lt; endl; for(auto x:m1){ cout \u0026lt;\u0026lt; x.first \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; x.second \u0026lt;\u0026lt; endl; } m2[1] = 1; m2[5] = 2; m2[3] = 3; cout \u0026lt;\u0026lt; \u0026quot;unordered_Map\u0026quot; \u0026lt;\u0026lt; endl; for(auto x:m2){ cout \u0026lt;\u0026lt; x.first \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; x.second \u0026lt;\u0026lt; endl; } }  Set #include \u0026lt;set\u0026gt; // 有序set #include \u0026lt;unordered_set\u0026gt; // 无序set #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ set\u0026lt;int\u0026gt; s1; unordered_set\u0026lt;int\u0026gt; s2; s1.insert(1); // 插入元素 s2.insert(1); }  ","id":9,"section":"posts","summary":"我的易忘点 pair头文件utility 无序map头文件unordered_map 优先队列拼写 priority_queue priority_queue #include \u0026lt;queue\u0026gt; // 优先队列 头文件 // 升序队列 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; q; // 降","tags":null,"title":"STL模板总结","uri":"https://coder-liuu.github.io/2021/02/stl/","year":"2021"},{"content":"最近使用Manjaro-Gnome系统已经快过去2年了，好多使用过的软件已经忘了，最近也打算重装系统，于是准备总结一下自己常用和好用的软件，以此记录，给自己和以后需要的人。\ngoogle-chrome 浏览器 浏览器是上网的必备，没有浏览器电脑的意义也就少了些许。\n安装：sudo pacman -S google-chrome\nTim 聊天软件 身为国人QQ，乃是必备。 安装：sudo pacman -S deepin.com.qq.im\nWps 常用办公软件 在线苦逼大学生写论文做PPT需要\n安装：sudo pacman -S wps-office\nnautilus 文件管理器 类似于Windows下的资源管理器，自带工具，无需安装\n安装：sudo pacman -S nautilus\n他的孪生兄弟thunar与他相似\n安装：sudo pacman -S thunar\nfoxit PDF阅读器 科研狗或喜欢看电子书必备软件，功能强大\n安装：sudo pacman -S foxit\nvscode 代码编辑器 强大且配置简单的无敌编辑器\n安装：sudo pacman -S code\npicgo 图床软件 以前使用在线图床过了一年图都消失啊，于是经过一番搜索发现了这个基于gitee的图床 官网：https://github.com/Molunerfinn/PicGo\n安装：yay -S picgo-appimage\n配置方式：TODO\nqv2ray 科学上网软件 科学上网你懂得～ 安装：sudo pacman -S qv2ray 图片就不放了\n网易云音乐（非官方客户端） 官方的网易云音乐在linux下有一个缺点就是在搜索框中不能输入中文，无奈之下找到了这个替代品\n安装：sudo pacman -S electron-netease-cloud-music\nxmind 思维导图 工程必备，思维导图，安装的使用需要snap来安装\n安装：https://snapcraft.io/install/xmind/manjaro\nfilezilila FTP传输软件 苦逼大学生使用FTP交作业\n安装：sudo pacman -S filezilila\ncpolar内网穿透软件 想将本地端口映射到域名地址，想在局域网外SSH链接电脑，这个软件就是这个作用\n官网：https://www.cpolar.com/\n安装：官网下载\nnavicat 数据库可视化软件 以excel方式查看数据库的数据集，老好用了，缺点就是只能免费用15天\n官网：https://www.navicat.com.cn/\n安装：官网下载\ndmenu 快速启动软件 快速启动一个软件\n安装：sudo pacman -S dmenu\nwine 模拟window软件 安装：sudo pacman -S wine\nfish 下载百度文库软件 苦逼大学生必备,linux需要用wine才能打开\n下载Fish.zip密码：i1ui\ntmux 终端复用软件 这个大名鼎鼎的终端复用软件，就不必多说了。\n安装：sudo pacman -S tmux\nranger 终端下的文件管理器 终端党必备，终端下的文件管理器\n安装：sudo pacman -S ranger\nzsh 好用的shell命令解释器 bash的进阶，具有自动补全，提示，扩展性更高。\n安装：sudo pacman -S zsh\nneovim 文本编辑软件 vim爱好者的终端下编辑器\n安装：sudo pacman -S neovim\nfzf 模糊搜索工具 通过文件名字，快速搜索一个文件\n安装：sudo pacman -S fzf\nag 代码搜索工具 在众多代码文件中搜索，某个变量\n安装：sudo pacman -S the_silver_searcher\n","id":10,"section":"posts","summary":"最近使用Manjaro-Gnome系统已经快过去2年了，好多使用过的软件已经忘了，最近也打算重装系统，于是准备总结一下自己常用和好用的软件，","tags":null,"title":"Manjaro常用软件","uri":"https://coder-liuu.github.io/2021/01/manjaro-softwork/","year":"2021"},{"content":"个人认为这部分的数论中的基础，刚刚有查了查蓝桥杯不考数论，所以这篇博客的数论知识都是一些基础知识。准备蓝桥杯还是好好学学动态规划和图论吧!\n质数 质数概念: 从2开始，只包含1和本身的约数，又称素数。\n性质: 若有n整除d，则n整除d/n $$ d | n \\rightarrow \\frac{d}{n} | n $$\n1-试除法判断质数模板 bool is_prime(int n){ if(n \u0026lt; 2) return false; for(int i = 2; i \u0026lt;= n / i; i++){ if(n % i == 0) return false; } return true; }  2-分解质因数(求一个数的所有质因数) void divide(int n){ for(int i = 2; i \u0026lt;= n / i; i++){ if(n % i == 0){ int s = 0; while(n % i == 0)n /= i,s++; // i 是底数，s是指数(有多少个i) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } } if(n \u0026gt; 1) cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; }  3-筛素数(判断1-n之间有多少个素数) 普通方法:枚举1-(n-1)来看看是否能筛掉n这个数\nvoid get_primes(int n){ for(int i = 2; i \u0026lt;= n ;i++){ if(st[i] == false){ ans++; } for(int j = i + i; j \u0026lt;= n; j+=i){ st[j] = true; } } }  埃氏方法:枚举1-(n-1)中的质数来看看是否能筛掉n这个数\nvoid get_primes(int n){ for(int i = 2; i \u0026lt;= n ;i++){ if(st[i] == false){ ans++; for(int j = i + i; j \u0026lt;= n; j+=i){ st[j] = true; } } } }  线性方法:使用n的最小质因数来筛掉n\nvoid get_primes(int n){ for(int i = 2; i \u0026lt;= n ;i++){ if(!st[i]) primes[ans++] = i; for(int j = 0; primes[j] \u0026lt;= n / i; j++){ st[primes[j] * i] = true; if(i % primes[j] == 0) break; } } }  4-试除法求约数 vector\u0026lt;int\u0026gt; get_divisors(int x) { vector\u0026lt;int\u0026gt; res; for (int i = 1; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { res.push_back(i); if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; }  5-约数相关公式 如果约数: $ N = p_{1}^{a1} * p_{2}^{a2} *\u0026hellip;* p_{k}^{ak} $\n约数个数: $ (a_{1} + 1) * (a_{2} + 2) * \u0026hellip; * (a_{k} + 1)$\n约数之和: $ (p_{1}^0 +p_{1}^1 +\u0026hellip; +p_{1}^{a1}) * \u0026hellip; * (p_{k}^0 +p_{k}^1 +\u0026hellip; +p_{k}^{ak}) $\n6-欧几里得算法(辗转相除法求最小公因数) int gcd(int a,int b){ return b ? gcd(b,a % b):a; }  7-求欧拉函数 定义: 1-N中于N互质的个数被称为欧拉函数，记为$ \\phi(N)$\n如果约数: $ N = p_{1}^{a1} * p_{2}^{a2} *\u0026hellip;* p_{k}^{ak} $\n求法: $ \\phi(N) = N * (1 - \\frac{1}{p_1}) * (1 - \\frac{1}{p_2}) * \u0026hellip; * (1 - \\frac{1}{p_k}) $\n8-筛法求欧拉函数 通过线性筛求很多欧拉函数\nint primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } }  9-快速幂 求$m^k \\mod p$ 时间复杂度logk\nLL f(LL a,LL b,LL p){ LL res = 1; while(b){ if(b \u0026amp; 1) res = (res * a) % p; a = (a * a) % p; b\u0026gt;\u0026gt;=1; } return res % p; }  10-求组合数 朴素求组合数,适用范围0-1000以内左右的组合数\nconst int N = 1010; int C[N][N]; for(int i = 0; i \u0026lt; N; i++){ for(int j = 0; j \u0026lt;= i; j++){ if(!j) C[i][j] = 1; else C[i][j] = C[i-1][j] + C[i-1][j-1]; } }  ","id":11,"section":"posts","summary":"个人认为这部分的数论中的基础，刚刚有查了查蓝桥杯不考数论，所以这篇博客的数论知识都是一些基础知识。准备蓝桥杯还是好好学学动态规划和图论吧! 质","tags":null,"title":"ACM数论","uri":"https://coder-liuu.github.io/2021/01/acm-math/","year":"2021"},{"content":"一、用Python第三方库virtualenv创建虚拟环境 这种方式是最原始最简单的一种方式.个人经常使用\n1. 安装方式 pip install virtualenv # python2 pip3 install virtualenv # python3  2.创建虚拟环境 virtualenv [虚拟环境的名字]  .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Tip\n这个虚拟环境会在你所在的目录生成，这里建议将所有的虚拟环境放在同一个目录下，容易管理\n 3.进入退出虚拟环境 linux进入虚拟环境 source /path/to/virtualenv/bin/activate\nlinux退出虚拟环境 deactivate\n4.安装所需的第三方库 当你进入虚拟环境，使用方式和pip的使用方法就都是一样的了。例如安装numpy库就是这样的命令pip3 install numpy\n5. 创建时指定python版本 创建时指定python版本需要加上-p选项,然后后面加上python的路径,比如这样: virtualenv -p /usr/bin/python3 py3env\n二、用Anaconda创建虚拟环境 这种方式是的优点是自动管理虚拟环境的目录，缺点就是安装的时候有点慢。 Warning\nconda是Anaconda里的一个工具，只有安装了Anaconda才会有的。\n 1. 创建虚拟环境 conda create -n ENV python==3.6  2. 激活/退出虚拟环境 激活虚拟环境 conda activate ENV\n退出虚拟环境 conda deactivate\n3. 安装所需的第三方库 conda install -n ENV [package]\n4. 查看conda环境下所有的虚拟环境 conda info --envs\n三、更换镜像源 1. pip 临时换源 pip install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple  2. Conda更换镜像源(Windows) conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/  3. Conda更换镜像源(Linux) 将以上配置文件写在~/.condarc中\nchannels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ ssl_verify: true  四、导出依赖包 1.导出当前环境下,所有的库 pip freeze \u0026gt; requirements.txt\n2.只导出所在项目的依赖包 # 安装pipreqs pip install pipreqs # 进行导出 pipreqs ./  3. 通过依赖包安装 pip install -r requirements.txt  参考博客 https://www.cnblogs.com/shyern/p/11284127.html\nhttps://www.cnblogs.com/shuaiyin/p/10922467.html\n","id":12,"section":"posts","summary":"一、用Python第三方库virtualenv创建虚拟环境 这种方式是最原始最简单的一种方式.个人经常使用 1. 安装方式 pip install virtualenv # python2 pip3 install virtualenv # python3 2.创","tags":null,"title":"Python-创建虚拟环境","uri":"https://coder-liuu.github.io/2020/04/python-create-vir/","year":"2020"},{"content":"最常用篇   初始化git仓库 git init\n  添加修改 git add .\n  删除git仓库,只需要删除本地的文件就可以了 rm -rf .git\n  查看当前仓库的状态 git status\n  丢弃工作区的改动 git restore \u0026lt;文件\u0026gt;\n  回滚撤回提交操作 git reset\n  告诉Git你是谁 git config --global user.name \u0026quot;Liu Yang\u0026quot;\n  提交东西 git commit -m \u0026quot;some describle\u0026quot; 如果这时候没有-m 和后面的东西将进入一个界面然后可以继续写自己的描述，修改后自动被提交\n  .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative} Tip\ngit commit \u0026ndash;amend 可以将这次提交追加到上一次提交中去，减少不必要的提交\n   配置默认编辑器git config --global core.editor nvim\n  让Git忽略一些东西，不被追踪 首先先新建一个文件.gitignore，然后将要忽略的文件写在上面就好了\n  让Git停止跟踪一个文件 git rm --cached ×××××\n  Git回滚篇   查看日志 git log\n  回滚到指定版本 git reset --hard id\n  回滚后看全部的历史提交记录 git reflog\n  删除git commit记录 git rebase -i xxxxxx(提交记录id),然后进入一个vim界面，把想删除的pick,改成drop保存退出，提交记录就没有了\n  高级篇   列出本地分支 git branch\n  添加一个分支 git branch xx(xx为分支名)\n  切换分支 git checkout xx(xx为分支名)\n  合并分支 git merge xx(xx为分支名)\n  添加远程仓库 git remote add origin xxx(xxx为网址)\n  解除远程仓库 git remote remove origin\n  提交到远程仓库里 git push --set-upstream origin master (!!! 本地至少的提交一次)\n  克隆仓库 git clone xxx(xxx为网址)\n  让Git记住你的帐号密码 git config credential.helper store\n  更新仓库,别人帮你做过修改，然后来更新自己的本地文件 git pull\n  在Github仓库的设置中可以邀请伙伴一起完成项目。\n  Git 查看自己的远程仓库git remote -v\n  Git其他常见操作 使用Git来提交一个PR  fork到自己仓库 git clone 到本地 上游建立连接  git remote add upstream 开源项目地址 创建并切换分支 git checkout -b new-xiaoming 提交代码 push到自己的仓库中去 去自己仓库的主页发现多了一个PR的按钮  不同时推送到gitee和github git remote add gitee https://gitee.com/monksoul/Fur.git git remote add github https://github.com/MonkSoul/Fur.git git push gitee git push github  同时推送到gitee和github gitee项目地址是:https://gitee.com/liu__yang/clustering-system\ngithub项目地址是https://github.com/Dreamer-liuyang/simple-clustering-system\n使用下面的命令关联两个数据库\ngit remote add origin https://gitee.com/xueleilei/nuxt-ssr-template.git git remote set-url --add origin https://github.com/xueleilei/nuxt-ssr-template.git git push  最后push时会同时push到两个仓库中\n推荐教程 练习网站 猴子教程 官方的中文文档\n","id":13,"section":"posts","summary":"最常用篇 初始化git仓库 git init 添加修改 git add . 删除git仓库,只需要删除本地的文件就可以了 rm -rf .git 查看当前仓库的状态 git status 丢弃工作区的改动 git restore \u0026lt","tags":null,"title":"Git命令总结","uri":"https://coder-liuu.github.io/2020/04/git-summary/","year":"2020"}],"tags":[]}